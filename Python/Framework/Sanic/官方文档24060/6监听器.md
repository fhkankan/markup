# 监听器

提供了8个侦听器，使您可以在应用程序生命周期的各个阶段运行代码。

## 自定义上下文

任意数据可以存储在`request.ctx`中。典型的用例是将从数据库中获取的用户对象存储在身份验证中间件中。在请求期间，所有以后的中间件以及处理程序都可以访问添加的密钥。

自定义上下文保留给应用程序和扩展。Sanic本身不使用它。

## 监听器

## 概述

主进程中

```
main_process_start
main_process_stop
```

自动加载开启时，在加载进程中

```
reload_process_start
reload_process_stop
```

服务器启动或关闭时执行启动/拆卸代码时

```
before_server_start
after_server_start
before_server_stop
after_server_stop
```

## 外部进程

如果此应用程序在启用自动重新加载的情况下运行，则当重新加载程序进程启动时，`reload_start`函数将被调用一次。当主进程启动时，`main_start`函数也将被调用一次。但是，`before-start`函数将为每个启动的工作进程调用一次，随后每次保存文件并重新启动工作进程时都会调用一次。

```python
@app.reload_process_start
async def reload_start(*_):
    print(">>>>>> reload_start <<<<<<")

@app.main_process_start
async def main_start(*_):
    print(">>>>>> main_start <<<<<<")
	
@app.before_server_start
async def before_start(*_):
	print(">>>>>> before_start <<<<<<")

```

## 附加监听

这些侦听器在接受应用程序对象以及异步循环的函数上作为装饰器实现。

```python
@app.listener('before_server_start')
async def setup_db(app, loop):
    app.db = await db_setup()

@app.listener('after_server_start')
async def notify_server_started(app, loop):
    print('Server successfully started!')

@app.listener('before_server_stop')
async def notify_server_stopping(app, loop):
    print('Server shutting down!')

@app.listener('after_server_stop')
async def close_db(app, loop):
    await app.db.close()
```

> 注意：监听者被解构的顺序与创建的顺序相反。

如果`before_server_start`中的第一个侦听器设置了数据库连接，那么在它之后注册的侦听器可以依赖于该连接在启动和停止时都处于活动状态，因为停止是按相反的顺序进行的，而数据库连接是在最后被拆掉的。

也可以使用`register_listener`方法注册一个侦听器。如果您在实例化应用程序的模块之外的其他模块中定义了侦听器，这可能会很有用。

```python
app = Sanic(__name__)

async def setup_db(app, loop):
    app.db = await db_setup()

app.register_listener(setup_db, 'before_server_start')
```

如果您希望安排后台任务在循环开始后运行，那么Sanic提供了`add_task`方法可以轻松地做到这一点。

```python
async def notify_server_started_after_five_seconds():
    await asyncio.sleep(5)
    print('Server successfully started!')

app.add_task(notify_server_started_after_five_seconds())
```

Sanic将尝试自动注入应用程序，并将其作为参数传递给任务：

```python
async def notify_server_started_after_five_seconds(app):
    await asyncio.sleep(5)
    print(app.name)

app.add_task(notify_server_started_after_five_seconds)
```

或者，您可以显式地传递应用程序以达到相同的效果：

```python
async def notify_server_started_after_five_seconds(app):
    await asyncio.sleep(5)
    print(app.name)

app.add_task(notify_server_started_after_five_seconds(app))
```



