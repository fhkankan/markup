# Nginx部署

## 概述

尽管Sanic可以直接在Internet上运行，但在它前面使用Nginx这样的代理服务器可能会很有用。这对于在同一个IP上运行多个虚拟主机、在单个Sanic应用程序旁边为nodej或其他服务提供服务特别有用，而且还允许高效地为静态文件提供服务。SSL和HTTP/2也很容易在这样的代理上实现。

我们将Sanic应用程序设置为仅在`127.0.0.1:8000`本地提供服务，而Nginx安装负责向域上的公共互联网提供服务example.com网站. 静态文件将从`/var/www/`提供。

##代理Sanic应用程序

该应用程序需要设置一个用于识别可信代理的密钥，这样才能识别真实的客户端IP和其他信息。这可以防止任何人在互联网上发送假请求头欺骗他们的IP地址和其他细节。选择任意随机字符串并在应用程序和Nginx配置中进行配置。

```python
from sanic import Sanic
from sanic.response import text

app = Sanic("proxied_example")
app.config.FORWARDED_SECRET = "YOUR SECRET"

@app.get("/")
def index(request):
    # This should display external (public) addresses:
    return text(
        f"{request.remote_addr} connected to {request.url_for('index')}\n"
        f"Forwarded: {request.forwarded}\n"
    )

if __name__ == '__main__':
    app.run(host='127.0.0.1', port=8000, workers=8, access_log=False)
```

由于这将是一个系统服务，请将代码保存到`/srv/sanicexample/sanicexample.py`.

要进行测试，请在终端中运行应用程序。

## Nginx配置

需要相当多的配置来允许快速透明代理，但在大多数情况下，这些都不需要修改，所以请接受我的建议。

`upstream`服务器需要在一个单独的`upstream`块中配置，以启用HTTP keep alive，这可以极大地提高性能，因此我们使用它，而不是在`proxy_pass`指令中直接提供`upstream`地址。在本例中，`upstream`部分由`server_name`命名，即公共域名，然后在主机头中传递给Sanic。您可以根据需要更改名称。还可以提供多个服务器用于负载平衡和故障切换。

根据网站的真实域名更改`example.com`的两个匹配项，使用你的应用程序选择的秘密替换`YOUR SECRET `。

```python
upstream example.com {
  keepalive 100;
  server 127.0.0.1:8000;
  #server unix:/tmp/sanic.sock;
}

server {
  server_name example.com;
  listen 443 ssl http2 default_server;
  listen [::]:443 ssl http2 default_server;
  # Serve static files if found, otherwise proxy to Sanic
  location / {
    root /var/www;
    try_files $uri @sanic;
  }
  location @sanic {
    proxy_pass http://$server_name;
    # Allow fast streaming HTTP/1.1 pipes (keep-alive, unbuffered)
    proxy_http_version 1.1;
    proxy_request_buffering off;
    proxy_buffering off;
    # Proxy forwarding (password configured in app.config.FORWARDED_SECRET)
    proxy_set_header forwarded "$proxy_forwarded;secret=\"YOUR SECRET\"";
    # Allow websockets
    proxy_set_header connection "upgrade";
    proxy_set_header upgrade $http_upgrade;
  }
}
```

为了避免cookie可见性问题和搜索引擎上的地址不一致，最好将所有访问者重定向到一个真正的域，始终使用HTTPS：

```python
# Redirect all HTTP to HTTPS with no-WWW
server {
  listen 80 default_server;
  listen [::]:80 default_server;
  server_name ~^(?:www\.)?(.*)$;
  return 301 https://$1$request_uri;
}

# Redirect WWW to no-WWW
server {
  listen 443 ssl http2;
  listen [::]:443 ssl http2;
  server_name ~^www\.(.*)$;
  return 301 $scheme://$1$request_uri;
}
```

上面的配置部分可以放在`/etc/nginx/sites available/default`或其他站点配置中（如果创建新的站点，请确保将它们符号链接到启用的站点）。

确保在主配置中配置了SSL证书，或者将`SSL_certificate`和`SSL_certificate_key`指令添加到侦听SSL的每个服务器部分。

另外，将所有这些内容复制并粘贴到`nginx/conf.d/forwarded.conf`

```python
# RFC 7239 Forwarded header for Nginx proxy_pass

# Add within your server or location block:
#    proxy_set_header forwarded "$proxy_forwarded;secret=\"YOUR SECRET\"";

# Configure your upstream web server to identify this proxy by that password
# because otherwise anyone on the Internet could spoof these headers and fake
# their real IP address and other information to your service.


# Provide the full proxy chain in $proxy_forwarded
map $proxy_add_forwarded $proxy_forwarded {
  default "$proxy_add_forwarded;by=\"_$hostname\";proto=$scheme;host=\"$http_host\";path=\"$request_uri\"";
}

# The following mappings are based on
# https://www.nginx.com/resources/wiki/start/topics/examples/forwarded/

map $remote_addr $proxy_forwarded_elem {
  # IPv4 addresses can be sent as-is
  ~^[0-9.]+$          "for=$remote_addr";

  # IPv6 addresses need to be bracketed and quoted
  ~^[0-9A-Fa-f:.]+$   "for=\"[$remote_addr]\"";

  # Unix domain socket names cannot be represented in RFC 7239 syntax
  default             "for=unknown";
}

map $http_forwarded $proxy_add_forwarded {
  # If the incoming Forwarded header is syntactically valid, append to it
  "~^(,[ \\t]*)*([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?(;([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?)*([ \\t]*,([ \\t]*([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?(;([!#$%&'*+.^_`|~0-9A-Za-z-]+=([!#$%&'*+.^_`|~0-9A-Za-z-]+|\"([\\t \\x21\\x23-\\x5B\\x5D-\\x7E\\x80-\\xFF]|\\\\[\\t \\x21-\\x7E\\x80-\\xFF])*\"))?)*)?)*$" "$http_forwarded, $proxy_forwarded_elem";

  # Otherwise, replace it
  default "$proxy_forwarded_elem";
}
```

对于不使用conf.d和可用站点的安装，上述所有配置也可以放在main的http部分中nginx.conf文件.

更改后重新加载Nginx配置：

```shell
sudo nginx -s reload
```

现在你应该可以在`https://example.com/`连接到你的app。任何404错误等都将由Sanic的错误页面处理，并且每当一个静态文件出现在给定的路径上时，Nginx将为其提供服务。

## SSL证书

如果您还没有在服务器上配置有效的证书，现在是这样做的好时机。安装`certbot,python3-certbot-nginx`，然后运行

```shell
certbot --nginx -d example.com -d www.example.com
```

https://www.nginx.com/blog/using-free-ssltls-certificates-from-lets-encrypt-with-nginx/

## 作为服务执行

这部分是针对基于systemd的Linux发行版的。创建单元文件`/etc/systemd/system/sanicexample.service`:

```shell
[Unit]
Description=Sanic Example

[Service]
User=nobody
WorkingDirectory=/srv/sanicexample
ExecStart=/usr/bin/env python3 sanicexample.py
Restart=always

[Install]
WantedBy=multi-user.target
```

然后重新加载服务文件，启动服务并在引导时启用：

```shell
sudo systemctl daemon-reload
sudo systemctl start sanicexample
sudo systemctl enable sanicexample
```

