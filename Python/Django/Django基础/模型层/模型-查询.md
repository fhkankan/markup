[TOC]

# 模型-查询

一旦你创建了[data models](https://yiyibooks.cn/__trs__/qy/django2/topics/db/models.html)，Django就会自动为你提供一个数据库抽象API，让你可以创建，检索，更新和删除对象。本文档介绍了如何使用此API。 有关所有各种模型查找选项的完整详细信息，请参阅[数据模型参考](https://yiyibooks.cn/__trs__/qy/django2/ref/models/index.html)。

## 模型与数据

参考模型

```python
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):
        return self.name

class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):
        return self.name

class Entry(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField()
    authors = models.ManyToManyField(Author)
    n_comments = models.IntegerField()
    n_pingbacks = models.IntegerField()
    rating = models.IntegerField()

    def __str__(self):
        return self.headline
```

创建对象

```python
# 有两个方法
save()  	# 在执行前，Django不会访问数据库，方法没有返回值
p = Person(first_name="Bruce", last_name="Springsteen")
p.save(force_insert=True)

create()  # 一条语句创建对象
p = Person.objects.create(first_name="Bruce", last_name="Springsteen")

# 示例
>>> from blog.models import Blog
>>> b = Blog(name='Beatles Blog', tagline='All the latest Beatles news.')
>>> b.save()  # 执行SQL的insert语句
```

更新对象

```python
# 更新普通字段
>>> b5.name = 'New name'
>>> b5.save()  # 执行SQL的update语句

# 更新ForeignKey
>>> from blog.models import Entry
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()

# 更新ManyToManyField
>>> from blog.models import Author
>>> joe = Author.objects.create(name="Joe")
>>> entry.authors.add(joe)  # 需使用add()增加关联关系的一条记录
>>> john = Author.objects.create(name="John")
>>> paul = Author.objects.create(name="Paul")
>>> entry.authors.add(john, paul)  # 多条记录
```

## 获取对象

通过模型中的`管理器`构造一个`查询集`，来从你的数据库中获取对象。

每个模型类默认都有一个叫 `objects `的类属性，它由django自动生成，类型为： `django.db.models.manager.Manager`，可以把它叫 模型管理器。

`查询集`表示从数据库中取出来的对象的集合。它可以含有零个、一个或者多个*过滤器*。过滤器基于所给的参数限制查询的结果。 

```shell
>>> Blog.objects  # 只可以通过模型的类访问
<django.db.models.manager.Manager object at ...>
>>> b = Blog(name='Foo', tagline='Bar')
>>> b.objects  # 不可以通过模型的实例访问
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."
```

### QuerySet特性

`filter(),exclude()`方法，返回QuerySet

```python
filter(**kwargs)
# 返回一个新的查询集，它包含满足查询参数的对象
exclude(**kwargs)
# 返回一个新的查询集，它包含不满足查询参数的对象

查询参数需要满足特定格式，详见“字段查询”
```

- 链式过滤

查询集的筛选结果还是查询集，所以可以将筛选语句链接在一起

```shell
>>> Entry.objects.filter(
...     headline__startswith='What'
... ).exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(
...     pub_date__gte=datetime(2005, 1, 30)
... )
```

对于空查询集可以链式过滤，过滤后的仍为空查询集

- 过滤后的查询集是独立的

每次筛选后得到的都是一个全新的独立的查询集，和之前的查询集没有任何绑定关系。可以被存储及反复使用

```shell
>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())
```

- 查询集是惰性执行的

创建查询集不会带来任何数据库的访问。只有在查询集需要求值时，Django才会真正运行这个查询

### 限制查询集

可以使用Python 的切片语法来限制`查询集`记录的数目 。它等同于SQL 的`LIMIT` 和`OFFSET` 子句。

```shell
>>> Entry.objects.all()[:5]
>>> Entry.objects.order_by('headline')[0]
```

第二条语句若没有对象，将引发`IndexError`

### 缓存和查询集

每个`查询集`都包含一个缓存来最小化对数据库的访问。在一个新创建的`查询集`中，缓存为空。首次对`查询集`进行求值 —— 同时发生数据库查询 ——Django 将保存查询的结果到`查询集`的缓存中并返回明确请求的结果（例如，如果正在迭代`查询集`，则返回下一个结果）。接下来对该`查询集`的求值将重用缓存的结果。

```python
# 相同的数据库查询执行两次，同时两个结果列表可能不相同(请求期间Entry被添或删)
>>> print([e.headline for e in Entry.objects.all()])
>>> print([e.pub_date for e in Entry.objects.all()])
# 保存查询机并重新使用
>>> queryset = Entry.objects.all()
>>> print([p.headline for p in queryset]) # Evaluate the query set.
>>> print([p.pub_date for p in queryset]) # Re-use the cache from the evaluation.
```

- 何时查询集不会被缓存

查询集不会永远缓存它们的结果。当只对查询集的*部分*进行求值时会检查缓存， 但是如果这个部分不在缓存中，那么接下来查询返回的记录都将不会被缓存。特别地，这意味着使用切片或索引来*限制查询集*将不会填充缓存。

注意：简单地打印查询集不会填充缓存。因为`__repr__()` 调用只返回全部查询集的一个切片。

```python
# 重复获取查询集对象中一个特定的索引将每次都查询数据库
>>> queryset = Entry.objects.all()
>>> print queryset[5] # Queries the database
>>> print queryset[5] # Queries the database again

# 如果已经对全部查询集求值过，则将检查缓存
>>> queryset = Entry.objects.all()
>>> [entry for entry in queryset] # Queries the database
>>> print queryset[5] # Uses cache
>>> print queryset[5] # Uses cache

# 使得全部的查询集被求值并填充到缓存中
>>> [entry for entry in queryset]
>>> bool(queryset)
>>> entry in queryset
>>> list(queryset)
```

### [查询集方法](https://yiyibooks.cn/xx/django_182/ref/models/querysets.html#queryset-api)

#### 返回新查询集

```python
filter(**kwargs)  
# 过滤，包含了与所给筛选条件相匹配的对象, 多参数时为AND关系过滤
exclude(**kwargs)  
# 排除，包含了与所给筛选条件不匹配的对象，底层SQL中多个参数通过AND连接，然后所有内容放入NOT()
annotate(*args,**kwargs)  
# 分组，使用提供的查询表达式列表注释QuerySet中的每个对象。 表达式可以是简单值，对模型（或任何相关模型）上的字段的引用，或者是通过与对象中的对象相关的对象计算的聚合表达式（平均值，总和等）
order_by(*fields)  
# 排序，隐式是升序排序，'-'前缀表示降序排序,'?'表示随机排序
reverse()  
# 对查询结果反向排序,只能在具有已定义顺序的QuerySet上调用(在model类的Meta中指定ordering或调用order_by()方法)。
distinct(*fields)  
# 从返回结果中剔除重复纪录(如果你查询跨越多个表，可能在计算QuerySet时得到重复的结果。此时可以使用distinct()，注意只有在PostgreSQL中支持按字段去重。)
values(*fields, **expressions)  
# 返回一个ValueQuerySet—一个特殊的QuerySet，迭代时得到的并不是模型实例化对象，而是一个字典序列
values_list(*fields, flat=False, named=False) 
# 它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列 
dates(field, kind, order='ASC')
# 返回DateQuerySet - QuerySet，其计算结果为datetime.date对象列表，表示特定种类的所有可用日期QuerySet。field应为模型的DateField的名称。 kind应为"year"、"month"或"day"。隐式的是升序排序。若要随机排序，请使用"?"，order（默认为“ASC”）应为'ASC'或'DESC'
datetimes(field, kind, order='ASC', tzinfo=None)
# 返回QuerySet，其值为datetime.datetime对象的列表，表示QuerySet内容中特定类型的所有可用日期。field应为模型的DateTimeField的名称。kind应为“year”，“month”，“day”，“hour”，“minute”或“second”。结果列表中的每个datetime.datetime对象被“截断”到给定的类型。order, 默认为'ASC', 可选项为'ASC' 或者 'DESC'. 这个选项指定了返回结果的排序方式。tzinfo定义在截断之前将数据时间转换到的时区。实际上，给定的datetime具有不同的表示，这取决于使用的时区。此参数必须是datetime.tzinfo对象。如果它无，Django使用当前时区。当USE_TZ为False时，它不起作用。
none()
# 调用none()将创建一个从不返回任何对象的查询集，并且在访问结果时不会执行任何查询。qs.none()查询集是EmptyQuerySet的一个实例。
all()  
# 返回当前QuerySet（或QuerySet 子类）的副本,当对QuerySet进行求值时，它通常会缓存其结果。如果数据库中的数据在QuerySet求值之后可能已经改变，你可以通过在以前求值过的QuerySet上调用相同的all() 查询以获得更新后的结果。
union(*other_qs, all=False)
# 使用SQL的UNION来结合多个QuerySet的结果，默认查询去重后的数据，若需有重复的数据，all设置为True
intersection(*other_qs)
# 使用SQL的INTERSECT运算符返回两个或多个QuerySet的共享元素
difference(*other_qs)
# 使用SQL的EXCEPT运算符仅保留QuerySet中存在的元素，而不保留其他一些QuerySet中的元素。
select_related(fields)
# 将“跟随”外键关系，在执行查询时选择其他相关对象数据。 这是一个性能增强器，它会导致一个单个更复杂的查询，但是也意味着以后再使用外键关系时，不会重新需要数据可查询。
prefetch_related(*lookups)
# 将在一个批处理中自动检索每个指定查找的相关对象。
extra(select=None, where=None, params=None, tables=None, order_by=None, select_params=None)
# 在 QuerySet生成的SQL从句中注入新子句,实现复杂where子句。参数可选，但必须有一个
defer(*fields)
# 延迟加载，不要从数据库中检索它们
only(*fields)
# 只有这些字段立即加载，其他都被推迟
using(alias)
# 使用多个数据库，空值查询集在哪个数据库上求值
select_for_update(nowwait=False)
# 锁定相关行知道事物结束，在支持的数据库上产生一个select...for update
raw(raw_query, params=None, translation=None)
# 接收一个原始SQL查询，执行它并返回一个django.db.models.query.RawQuerySet 实例。这个RawQuerySet 实例可以迭代以提供实例对象，就像普通的QuerySet 一样。
```

- 示例

filter

```python
paper_list.filter(name__icontains=name)
```

exclude

```python
Entry.objects.exclude(pub_date__gt=datetime.date(2005, 1, 3), headline='Hello')
```

Annotate

```python
# 不指定名字,默认关键自作为Annotation的别名，只适用于单个字段
>>> from django.db.models import Count
>>> q = Blog.objects.annotate(Count('entry'))
>>> q[0].name  # 第一个blog的名字
'Blogasaurus'
>>> q[0].entry__count  # 第一个blog的entry_count的值，Entity的数量
42

# 指定名字
>>> q = Blog.objects.annotate(number_of_entries=Count('entry'))
# The number of entries on the first blog, using the name provided
>>> q[0].number_of_entries
42
```

Order_by

```python
Entry.objects.filter(pub_date__year=2005).order_by('-pub_date', 'headline')
Entry.objects.order_by('?')  # 随机
Entry.objects.order_by('blog__name', 'headline')  # 关联字段
Entry.objects.order_by('blog_id')  #  无join
Entry.objects.order_by('blog__id')  # Join
Entry.objects.order_by(Coalesce('summary', 'headline').desc())  # 表达式
Entry.objects.order_by(Lower('headline').desc())  # 大小写
Entry.objects.order_by('headline').order_by('pub_date')  # 最后一个有效
Entry.objects.order_by()  # 默认的排序
# 检查是否有任何方式的排序
QuerySet.ordered  # True/False
# 影响distinct(),values()
# order_by调用的字段会包含在SELECT中，可能会有重复行，
# 指定一个多值字段来排序结果（ManyToManyField或ForeignKey的反向关联)
class Event(Model):
   parent = models.ForeignKey('self', related_name='children')
   date = models.DateField()
Event.objects.order_by('children__date')  # 会返回扩大的新QuerySet,需注意慎用
```

reverse

```python
my_queryset.reverse()[:5]  # 后5个元素
```

distinct

```python
Author.objects.distinct()

# 如果你使用的是distinct()和order_by()，请注意相关模型的排序
# 当一起使用distinct()和values()时，请注意字段在不在values()
```

values

```shell
# 多字段
>>> Blog.objects.values()
[{'id': 1, 'name': 'Beatles Blog', 'tagline': 'All the latest Beatles news.'}],
>>> Blog.objects.values('id', 'name')
[{'id': 1, 'name': 'Beatles Blog'}]
# 表达式， 1.11支持表达式
>>> from django.db.models.functions import Lower
>>> Blog.objects.values(lower_name=Lower('name'))
<QuerySet [{'lower_name': 'beatles blog'}]>
# 聚合
>>> from django.db.models import Count
>>> Blog.objects.values('author', entries=Count('entry'))
<QuerySet [{'author': 1, 'entries': 20}, {'author': 1, 'entries': 13}]>
>>> Blog.objects.values('author').annotate(entries=Count('entry'))
<QuerySet [{'author': 1, 'entries': 33}]>
# Foreignkey
>>> Entry.objects.values()
[{'blog_id': 1, 'headline': 'First Entry', ...}, ...]
>>> Entry.objects.values('blog')
[{'blog': 1}, ...]
>>> Entry.objects.values('blog_id')
[{'blog_id': 1}, ...]
# 反向关联
>>> Blog.objects.values('name', 'entry__headline')
<QuerySet [{'name': 'My blog', 'entry__headline': 'An entry'},
     {'name': 'My blog', 'entry__headline': 'Another entry'}, ...]>
# 注意
- 当values() 与distinct() 一起使用时，注意排序可能影响最终的结果。
- 如果values() 子句位于extra() 调用之后，extra() 中的select 参数定义的字段必须显式包含在values() 调用中。values() 调用后面的extra() 调用将忽略选择的额外的字段。
- 在values() 之后调用only() 和defer() 不太合理，所以将引发一个NotImplementedError。
```

values_list

```shell
# 多字段
>>> Entry.objects.values_list()
<QuerySet [(1, 'First entry',...), ...]>
>>> Entry.objects.values_list('id', 'headline')
<QuerySet [(1, 'First entry'), ...]>
#  表达式， 1.11支持字段上加表达式
>>> from django.db.models.functions import Lower
>>> Entry.objects.values_list('id', Lower('headline'))
<QuerySet [(1, 'first entry'), ...]>

# 单字段
>>> Entry.objects.values_list('id').order_by('id')
<QuerySet[(1,), (2,), (3,), ...]>
>>> Entry.objects.values_list('id', flat=True).order_by('id')
<QuerySet [1, 2, 3, ...]>
# 关键字， 2.0支持named
>>> Entry.objects.values_list('id', 'headline', named=True)
<QuerySet [Row(id=1, headline='First entry'), ...]>

# ForeignKey
>>> Entry.objects.values_list('authors')
<QuerySet [('Noam Chomsky',), ('George Orwell',), (None,)]>

# manyToMany
>>> Author.objects.values_list('name', 'entry__headline')
<QuerySet [('Noam Chomsky', 'Impressions of Gaza'),
 ('George Orwell', 'Why Socialists Do Not Believe in Fun'),
 ('George Orwell', 'In Defence of English Cooking'),
 ('Don Quixote', None)]>
```

date

```shell
>>> Entry.objects.dates('pub_date', 'year') # 去过重的year
[datetime.date(2005, 1, 1)]
>>> Entry.objects.dates('pub_date', 'month')  # 去过重的year/month
[datetime.date(2005, 2, 1), datetime.date(2005, 3, 1)]
>>> Entry.objects.dates('pub_date', 'day')  # 去过重的year/month/day
[datetime.date(2005, 2, 20), datetime.date(2005, 3, 20)]
>>> Entry.objects.dates('pub_date', 'day', order='DESC')
[datetime.date(2005, 3, 20), datetime.date(2005, 2, 20)]
>>> Entry.objects.filter(headline__contains='Lennon').dates('pub_date', 'day')
[datetime.date(2005, 3, 20)]
```

none

```shell
>>> Entry.objects.none()
<QuerySet []>
>>> from django.db.models.query import EmptyQuerySet
>>> isinstance(Entry.objects.none(), EmptyQuerySet)
True
```

union/intersection/difference

```shell
# 1.11新增
>>> qs1.union(qs2, qs3)
>>> qs1.intersection(qs2, qs3)
>>> qs1.difference(qs2, qs3)
# union,intersection,difference会返回第一个QuerySet类型模型实例，即使变量是其他模型的QuerySet。只要所有QuerySet中的SELECT列表相同，传递不同的模型就会起作用（至少类型，只要类型相同，名称无关紧要）。在这种情况下，您必须使用应用于生成的QuerySet的QuerySet方法中的第一个QuerySet中的列名。
>>> qs1 = Author.objects.values_list('name')
>>> qs2 = Entry.objects.values_list('headline')
>>> qs1.union(qs2).order_by('name')
# 在结果QuerySet上只允许LIMIT,OFFSET,COUNT(*),ORDER BY和指定列(如slicing,count(),order_by()和values()/values_list())。此外，数据库限制组合查询中允许的操作。例如，大多数数据库在组合查询中不允许LIMIT或OFFSET。
```

Select_related

```python
# 标准查询
e = Entry.objects.get(id=5)  # Hits the database.
b = e.blog  # Hits the database again to get the related Blog object.

# select_related
e = Entry.objects.select_related('blog').get(id=5)  # Hits the database.
b = e.blog  # Doesn't hit the database, because e.blog has been prepopulated in the previous query.

# 需要清除QuerySet上过去调用select_related所添加的相关字段列表
without_relations = queryset.select_related(None)

# 多参数与链式调用类似
select_related('foo', 'bar')
select_related('foo').select_related('bar')

# 任意对象的查询集上均可用
rom django.utils import timezone

blogs = set()  # Find all the blogs with entries scheduled to be published in the future.

for e in Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog'):
    # Without select_related(), this would make a database query for each
    # loop iteration in order to fetch the related blog for each entry.
    blogs.add(e.blog)
    
# filter()和select_related()之间的链接顺序并不重要，如下等价
Entry.objects.filter(pub_date__gt=timezone.now()).select_related('blog')
Entry.objects.select_related('blog').filter(pub_date__gt=timezone.now())

# 外键查询
from django.db import models

class City(models.Model):
    # ...
    pass
class Person(models.Model):
    # ...
    hometown = models.ForeignKey(
        City,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
class Book(models.Model):
    # ...
    author = models.ForeignKey(Person, on_delete=models.CASCADE)

# 如下操作将会缓存与其相关的Person和 City关系:
b = Book.objects.select_related('author__hometown').get(id=4)
p = b.author         # Doesn't hit the database.
c = p.hometown       # Doesn't hit the database.

b = Book.objects.get(id=4) # No select_related() in this example.
p = b.author         # Hits the database.
c = p.hometown       # Hits the database.

# 在传递给select_related() 的字段中，你可以使用任何ForeignKey 和OneToOneField。
# 在传递给select_related 的字段中，你还可以反向引用OneToOneField —— 也就是说，你可以回溯到定义OneToOneField 的字段。此时，可以使用关联对象字段的related_name，而不要指定字段的名称。
```

Preach_related

```python
# 具有与select_related类似的目的，两者都被设计为阻止由访问相关对象而导致的数据库查询的泛滥，但是策略是完全不同的。
# select_related通过创建SQL连接并在SELECT语句中包括相关对象的字段来工作。因此，select_related在同一数据库查询中获取相关对象。然而，为了避免由于跨越“多个”关系而导致的大得多的结果集，select_related限于单值关系 - 外键和一对一关系。
# prefetch_related 独立查找每个关系，并在Python中执行“关联(joining)”。这允许它除了select_related支持的外键和一对一关系以外, 还能预取多对多和多对一对象，这正是select_related不能实现的。prefetch_related 还支持GenericRelation 和 GenericForeignKey的预取.
```

extra

```python
# select
# 在 SELECT 从句中添加其他字段信息，它应该是一个字典，存放着属性名到 SQL 从句的映射。
Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})
Blog.objects.extra(
    select={
        'entry_count': 'SELECT COUNT(*) FROM blog_entry WHERE blog_entry.blog_id = blog_blog.id'
    },
)
Blog.objects.extra(
    select=OrderedDict([('a', '%s'), ('b', '%s')]),
    select_params=('one', 'two'))

# where/tables
# 可以使用where定义显式SQL WHERE子句 - 也许执行非显式连接。您可以使用tables手动将表添加到SQL FROM子句。where和tables都接受字符串列表。所有where参数均为“与”任何其他搜索条件
Entry.objects.extra(where=["foo='a' OR bar = 'a'", "baz = 'a'"])
Entry.objects.extra(where=['headline=%s'], params=['Lennon'])

# order_by
# 如需要使用通过extra()包含的一些新字段或表来对结果查询进行排序，请使用order_by参数extra()并传入一个字符串序列。这些字符串应该是模型字段（如查询集上的正常order_by()方法），形式为table_name.column_name或您在select参数到extra()
q = Entry.objects.extra(select={'is_recent': "pub_date > '2006-01-01'"})
q = q.extra(order_by = ['-is_recent'])
```

defer

```python
# 传递字段名不加载到defer()
Entry.objects.defer("headline", "body")
# 多次调用，均会添加新字段，顺序无关
Entry.objects.defer("body").filter(rating=5).defer("headline")
# 关联模型
Blog.objects.select_related().defer("entry__headline", "entry__body")
# 清空延迟字段
my_queryset.defer(None)
```

only

```python
# 就延迟而言，如下等价
Person.objects.defer("age", "biography")
Person.objects.only("name")

# 连续调用，只有最后有效
Entry.objects.only("body", "rating").only("headline")

# defer与only连用
Entry.objects.only("headline", "body").defer("body")  # Final result is that everything except "headline" is deferred.
Entry.objects.defer("body").only("headline", "body")  # Final result loads headline and body immediately (only() replaces any existing set of fields).
```

using

```shell
# queries the database with the 'default' alias.
>>> Entry.objects.all()

# queries the database with the 'backup' alias
>>> Entry.objects.using('backup')
```

select_for_update

```python
entries = Entry.objects.select_for_update().filter(author=request.user)  # 所有匹配的行将被锁定，直到事务结束。这意味着可以通过锁防止数据被其它事务修改

# 解决阻塞
一般情况下如果其他事务锁定了相关行，那么本查询将被阻塞，直到锁被释放。如果这不是你想要的行为，可以使用如下方法之一：
1. 请使用select_for_update(nowait=True). 这将使查询不阻塞。如果其它事务持有冲突的锁, 那么查询将引发 DatabaseError 异常
2.可以使用select_for_update(skip_locked=True)来忽略行锁定。nowait和skip_locked是互斥的，并且尝试在启用两个选项的情况下调用select_for_update（）将导致ValueError。

# nullable关系不能使用
>>> Person.objects.select_related('hometown').select_for_update()
Traceback (most recent call last):
...
django.db.utils.NotSupportedError: FOR UPDATE cannot be applied to the nullable side of an outer join
# 若是不关注null对象，可排除
>>> Person.objects.select_related('hometown').select_for_update().exclude(hometown=None)
<QuerySet [<Person: ...)>, ...]>
```

#### 不返回查询集

```python
get(**kwargs)   
# 返回与所给筛选条件相匹配的对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。
create(**kwargs)
# 一个在一步操作中同时创建对象并且保存的便捷方法. 
get_or_create(defaults=None, **kwargs)
# 一个通过给出的kwargs 来查询对象的便捷方法（如果你的模型中的所有字段都有默认值，可以为空），需要的话创建一个对象。返回一个由(object, created)组成的元组，元组中的object 是一个查询到的或者是被创建的对象， created 是一个表示是否创建了新的对象的布尔值。
update_or_create(defaults=None, **kwargs)
# 一个通过给出的kwargs 来更新对象的便捷方法， 如果需要的话创建一个新的对象。defaults 是一个由 (field, value) 对组成的字典，用于更新对象。返回一个由 (object, created)组成的元组,元组中的object 是一个创建的或者是被更新的对象， created 是一个标示是否创建了新的对象的布尔值。尝试通过给出的kwargs 去从数据库中获取匹配的对象。如果找到匹配的对象，它将会依据defaults 字典给出的值更新字段。
bulk_create(objs, batch_size=None)
# 此方法以有效的方式（通常只有1个查询，无论有多少对象）将提供的对象列表插入到数据库中。batch_size参数控制在单个查询中创建的对象数。默认值是在一个批处理中创建所有对象，除了SQLite，其中默认值为每个查询最多使用999个变量。
count()
# 返回数据库中匹配查询(QuerySet)的对象数量。永远不会引发异常
in_bulk(id_list=None, field_name='pk')
# 获取主键值的列表和字段名，并返回将每个主键值映射到具有给定ID的对象的实例的字典。若主键列表缺省，返回所有，field_name必须是唯一的，默认主键
iterator(chunk_size=2000)
# 评估QuerySet（通过执行查询），并返回一个迭代器。
latest(*fields)
# 使用作为日期字段提供的field_name，按日期返回表中的最新对象。
earliest(*fields)
# 除非方向更改，类似latest()
first()
# 返回结果集的第一个对象, 当没有找到时返回None.如果 QuerySet 没有设置排序,则将会自动按主键进行排序
last()
# 返回最后一条记录对象 ,当没有找到时返回None.如果 QuerySet 没有设置排序,则将会自动按主键进行排序
aggregate(*args, **kwargs)
# 聚合，返回一个字典，包含根据QuerySet计算得到的聚合值（平均数、和等等）。aggregate() 的每个参数指定返回的字典中将要包含的值
exists()
# 如果QuerySet包含数据，就返回True，否则返回False
update(**kwargs)
# 对指定的字段执行SQL更新查询，并返回匹配的行数（如果某些行已具有新值，则可能不等于已更新的行数）。不能在已采取切片或以其他方式无法过滤的QuerySet上调用
delete()
# 对QuerySet中的所有行执行SQL删除查询。立即应用delete()。不能在已采取切片或以其他方式无法过滤的QuerySet上调用delete()
as_manager()
# 类方法返回一个复制了QueSet方法的Manager对象的实例
```

- 示例

get

```python
Entry.objects.get(id='foo') # raises Entry.DoesNotExist
```

create

```python
p = Person.objects.create(first_name="Bruce", last_name="Springsteen")

p = Person(first_name="Bruce", last_name="Springsteen")
p.save(force_insert=True)
```

get_or_create

```python
# 1.11支持defaults中设置可调用值
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
except Person.DoesNotExist:
    obj = Person(first_name='John', last_name='Lennon', birthday=date(1940, 10, 9))
    obj.save()
    
# 改写为
obj, created = Person.objects.get_or_create(first_name='John', last_name='Lennon', defaults={'birthday': date(1940, 10, 9)})

# 创建逻辑
params = {k: v for k, v in kwargs.items() if '__' not in k}
params.update(defaults)
obj = self.model(**params)
obj.save()

# 有名为defaults的字段，做精确查询
Foo.objects.get_or_create(defaults__exact='bar', defaults={'defaults': 'baz'})

# 反向关联
class Chapter(models.Model):
    title = models.CharField(max_length=255, unique=True)

class Book(models.Model):
    title = models.CharField(max_length=256)
    chapters = models.ManyToManyField(Chapter)

>>> book = Book.objects.create(title="Ulysses")
>>> book.chapters.get_or_create(title="Telemachus")
(<Chapter: Telemachus>, True)
>>> book.chapters.get_or_create(title="Telemachus")
(<Chapter: Telemachus>, False)
>>> Chapter.objects.create(title="Chapter 1")
<Chapter: Chapter 1>
>>> book.chapters.get_or_create(title="Chapter 1")
# Raises IntegrityError
```

Update_create

```python
# 在1.11支持defaults中使用可调用值
defaults = {'first_name': 'Bob'}
try:
    obj = Person.objects.get(first_name='John', last_name='Lennon')
    for key, value in defaults.items():
        setattr(obj, key, value)
    obj.save()
except Person.DoesNotExist:
    new_values = {'first_name': 'John', 'last_name': 'Lennon'}
    new_values.update(defaults)
    obj = Person(**new_values)
    obj.save()
    
# uodate_create简写
obj, created = Person.objects.update_or_create(
    first_name='John', last_name='Lennon',
    defaults={'first_name': 'Bob'},
)
```

Bulk_create

```shell
>>> Entry.objects.bulk_create([
...     Entry(headline="Django 1.0 Released"),
...     Entry(headline="Django 1.1 Announced"),
...     Entry(headline="Breaking: Django is awesome")
... ])

# 注意：
- 将不会调用模型的save()方法，并且不会发送pre_save和post_save信号。
- 它不适用于多表继承场景中的子模型。
- 如果模型的主键是AutoField，它不会像save()那样检索和设置主键属性。
- 它不适用于多对多关系
- 它将objs转换为一个列表，如果它是一个生成器，它会完全评估objs。强制转换允许检查所有对象，以便可以首先插入具有手动设置主键的任何对象。如果要在不评估整个生成器的情况下立即批量插入对象，只要对象没有任何手动设置的主键，就可以使用此技术：
from itertools import islice

batch_size = 100
objs = (Entry(headling'Test %s' % i) for i in range(1000))
while True:
    batch = list(islice(objs, batch_size))
    if not batch:
        break
    Entry.objects.bulk_create(batch, batch_size)
```

count

```python
# Returns the total number of entries in the database.
Entry.objects.count()

# Returns the number of entries whose headline contains 'Lennon'
Entry.objects.filter(headline__contains='Lennon').count()

# count()在后台执行SELECT COUNT（*） count()，而不是将所有的记录加载到Python对象中并在结果上调用len()（除非你需要将对象加载到内存中， len()会更快）。
# 如果您想要QuerySet中的项目数量，并且还要从中检索模型实例（例如，通过迭代它），使用len（查询集）更有效，这不会像count()一样导致额外的数据库查询。
```

is_bulk

```shell
>>> Blog.objects.in_bulk([1])
{1: <Blog: Beatles Blog>}
>>> Blog.objects.in_bulk([1, 2])
{1: <Blog: Beatles Blog>, 2: <Blog: Cheddar Talk>}
>>> Blog.objects.in_bulk([])  #  传空列表会得到空字典
{}
>>> Blog.objects.in_bulk()
{1: <Blog: Beatles Blog>, 2: <Blog: Cheddar Talk>, 3: <Blog: Django Weblog>}
# field_name在2.0新增
>>> Blog.objects.in_bulk(['beatles_blog'], field_name='slug')
{'beatles_blog': <Blog: Beatles Blog>}
```

iterator

```python
# chunk_size参数在2.0添加

# QuerySet通常在内部缓存其结果，以便在重复计算是不会导致额外的查询。相反，iterator()将直接读取结果，而不在QuerySet级别执行任何缓存（内部，默认迭代器调用iterator()并高速缓存返回值）。对于返回大量只需要访问一次的对象的QuerySet，这可以带来更好的性能和显着减少内存。

# 请注意，在已经求值了的QuerySet上使用iterator()会强制它再次计算，重复查询。

# 此外，使用iterator()会导致先前的prefetch_related()调用被忽略，因为这两个优化一起没有意义。
```

latest/earliest

```python
Entry.objects.latest('pub_date')
# 2.0支持多变量
Entry.objects.latest('pub_date', '-expire_date')

# get,latest,earliest对于查询无对象时，抛出DoesNotExist错误
```

first/last

```python
p = Article.objects.order_by('title', 'pub_date').first()
# 等价于如下
try:
    p = Article.objects.order_by('title', 'pub_date')[0]
except IndexError:
    p = None
```

aggregate

```python
# 使用关键字参数指定的聚合将使用关键字参数的名称作为Annotation 的名称。匿名的参数的名称将基于聚合函数的名称和模型字段生成。复杂的聚合不可以使用匿名参数，它们必须指定一个关键字参数作为别名。
# 默认
>>> from django.db.models import Count
>>> q = Blog.objects.aggregate(Count('entry'))
{'entry__count': 16}
# 指定名称
>>> q = Blog.objects.aggregate(number_of_entries=Count('entry'))
{'number_of_entries': 16}
```

exists

```python
entry = Entry.objects.get(pk=123)
# 此方法优于下面
if some_queryset.filter(pk=entry.pk).exists():
    print("Entry contained in queryset")

if entry in some_queryset:
   print("Entry contained in QuerySet")
```

update

```shell
>>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False)
# 更新多个字段
>>> Entry.objects.filter(pub_date__year=2010).update(comments_on=False, headline='This is old')
# 立即应用，对更新的QuerySet的唯一限制是它只能访问一个数据库表，也就是模型的主表，而不是相关模型
>>> Entry.objects.update(blog__name='foo') # Won't work!
# 使用关联字段查询时可以的
>>> Entry.objects.filter(blog__id=1).update(comments_on=True)
# F()对象
>>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)  # ok
# THIS WILL RAISE A FieldError
>>> Entry.objects.update(headline=F('blog__name'))  # wrong,不可引入join

# 如果你只是更新一个记录，不需要对模型对象做任何事情，最有效的方法是调用update()，而不是将模型对象加载到内存中
# not do this
e = Entry.objects.get(id=10)
e.comments_on = False
e.save()
# to do this
Entry.objects.filter(id=10).update(comments_on=False)

# update会直接转换成一个SQL语句，时一个批量的直接更新操作。不执行save()，也不传输pre_save和post_save信号，若是需要调用自定义的save()方法
for e in Entry.objects.filter(pub_date__year=2010):
    e.comments_on = False
    e.save()
```

delete

```shell
>>> b = Blog.objects.get(pk=1)
# Delete all the entries belonging to this Blog.
>>> Entry.objects.filter(blog=b).delete()  # 批量删除
(4, {'weblog.Entry': 2, 'weblog.Entry_authors': 2})
>>> b.delete()  # 单独删除


# ForeignKey
# 默认情况下，Django的ForeignKey模拟SQL约束ON DELETE CASCADE字，任何具有指向要删除的对象的外键的对象将与它们一起被删除。
>>> blogs = Blog.objects.all()
# This will delete all Blogs and all of their Entry objects.
>>> blogs.delete()
(5, {'weblog.Blog': 1, 'weblog.Entry': 2, 'weblog.Entry_authors': 2})

# 此级联行为可通过ForeignKey的on_delete参数自定义。

# delete()方法执行批量删除，并且不会在模型上调用任何delete()方法。但它会为所有已删除的对象（包括级联删除）发出pre_delete和post_delete信号。若要使用自定义的delete()方法
for e in Entry.objects.filter(pub_date__year=2010):
    e.save()

# Django需要获取对象到内存中以发送信号和处理级联。然而，如果没有级联和没有信号，那么Django可以采取快速路径并删除对象而不提取到内存中。对于大型删除，这可以显着减少内存使用。执行的查询量也可以减少。

# 设置为on_delete DO_NOTHING的外键不会阻止删除快速路径。
```

### 字段查询

字段查询是指如何指定SQL `WHERE` 子句的内容。它们通过查询集方法的关键字参数指定。

基本形式

```
field__lookuptype=value
```

字段名

```
查询条件中指定的字段必须是模型字段的名称

ForeignKey在字段名加上`_id`后缀时，该参数的值应该是外键的原始值
```

字段查询参数

```python
exact  # 精确等于,若参数为None，则按照NULL进行SQL，SQL中=
iexact  # 不区分大小写的精确匹配,若参数为None，则按照NULL进行SQL，SQL中ilike
contains  # 区分大小写的包含，SQL中like '%...%'
icontains  # 不区分大小写的包含, SQL中ilike '%...%'
in  # 在给定的列表, SQL中in(...,...)
exclude  # 
gt  # 大于,SQL中>
gte  # 大于等于
lt  # 小于
lte  # 小于等于
startswith  # 区分大小写，开始位置匹配, SQL中like '...%'
istartswith  # 不区分大小写，开始位置匹配,SQL中ilike '...%'
endswith  # 以…结尾, 区分大小写，SQL中like '%...'
iendswith # 以…结尾，忽略大小写,SQL中ilike '%...'
rang	# 在…范围内, SQL中between...with...
year  # 对于日期和日期时间字段，确切的年匹配。整数年
month  # 对于日期和日期时间字段，确切的月份匹配。取整数1~12
day  # 对于日期和日期时间字段，具体到某一天的匹配。取一个整数的天数
week  # 对于日期和日期时间字段，取周数（1-52或53），即周一开始周数，第一周开始于周四或之前。
week_day # 对于日期和日期时间字段，“星期几”匹配。取整数值，表示星期几从1(星期日)到7(星期六)
quarter  # 对于日期和日期时间字段，“一年中的四分之一”匹配。允许链接其他字段查找。取1到4之间的整数值，表示一年中的四分之一。
time  # 对于datetime字段，将值转换为时间。允许链接其他字段查找。采用datetime.time值。
hour  # 对于日期时间字段，精确的小时匹配。取0和23之间的整数
minute  # 对于日期时间字段，精确的分钟匹配。取0和59之间的整数
second  # 对于datetime字段，精确的第二个匹配。取0和59之间的整数。
isnull  # 值为 True 或 False, 相当于 SQL语句IS NULL和IS NOT NULL.
search  # 一个Boolean类型的全文搜索，以全文搜索的优势。这个很像 contains ，但是由于全文索引的优势，以使它更显著的快
regex  # 区分大小写的正则表达式匹配
iregex  # 不区分大小写的正则表达式匹配
# 正则表达式语法是正在使用的数据库后端的语法。在SQLite没有内置正则表达式支持的情况下，此功能由（Python）用户定义的REGEXP函数提供，因此正则表达式语法是Python的re模块。
```

示例

```python
# exact/iexact
Entry.objects.get(id__exact=14)
Entry.objects.get(id__exact=None)  # SQL中使用is NULL
Blog.objects.get(name__iexact='beatles blog')
Blog.objects.get(name__iexact=None)  # SQL中使用is NULL
# contains/icontains
Entry.objects.get(headline__contains='Lennon')
Entry.objects.get(headline__icontains='Lennon')
# in
Entry.objects.filter(id__in=[1, 3, 4])
inner_qs = Blog.objects.filter(name__contains='Cheddar')  # 动态查询
entries = Entry.objects.filter(blog__in=inner_qs)
inner_qs = Blog.objects.filter(name__contains='Ch').values('name')  # 嵌套查询
entries = Entry.objects.filter(blog__name__in=inner_qs)
values = Blog.objects.filter(name__contains='Cheddar').values_list('pk', flat=True)  # 分步查询
entries = Entry.objects.filter(blog__in=list(values))
# gt,gte,lt,lte
Entry.objects.filter(id__gt=4)
# startwith,istartwith,endwith,iendwith
Entry.objects.filter(headline__startswith='Will')
Entry.objects.filter(headline__istartswith='will')
Entry.objects.filter(headline__endswith='cats')
Entry.objects.filter(headline__iendswith='will')
# range
import datetime
start_date = datetime.date(2005, 1, 1)
end_date = datetime.date(2005, 3, 31)
Entry.objects.filter(pub_date__range=(start_date, end_date))  # 过滤具有日期的DateTimeField不会包含最后一天的项目，因为边界被解释为“给定日期的0am”
# year,month,day,week,week_day,quarter,time,hour,minute,second
Entry.objects.filter(pub_date__year=2005)
SELECT ... WHERE pub_date BETWEEN '2005-01-01' AND '2005-12-31';  # 等价SQL
Entry.objects.filter(pub_date__month=12)
SELECT ... WHERE EXTRACT('month' FROM pub_date) = '12';  # 等价SQL
Entry.objects.filter(pub_date__day=3)  
SELECT ... WHERE EXTRACT('day' FROM pub_date) = '3';  # 等价SQL
Entry.objects.filter(pub_date__week__gte=32, pub_date__week__lte=38)
Entry.objects.filter(pub_date__week_day=2)
Entry.objects.filter(pub_date__quarter=2)
Entry.objects.filter(pub_date__time__between=(datetime.time(8), datetime.time(17)))
Event.objects.filter(timestamp__hour=23)
SELECT ... WHERE EXTRACT('hour' FROM timestamp) = '23'; # 等价SQL
Event.objects.filter(timestamp__minute=29)
SELECT ... WHERE EXTRACT('minute' FROM timestamp) = '29';  # 等价SQL
Event.objects.filter(timestamp__second=31)
SELECT ... WHERE EXTRACT('second' FROM timestamp) = '31';  # 等价SQL
# isnull
Entry.objects.filter(pub_date__isnull=True)
# search
Entry.objects.filter(headline__search="+Django -jazz Python")
SELECT ... WHERE MATCH(tablename, headline) AGAINST (+Django -jazz Python IN BOOLEAN MODE);  # 等价SQL
# regex/iregex
Entry.objects.get(title__regex=r'^(An?|The) +')
SELECT ... WHERE title REGEXP BINARY '^(An?|The) +'; -- MySQL  # 等价SQL
Entry.objects.get(title__iregex=r'^(an?|the) +')
```

### 聚合函数

```python
Avg(expression, output_field=FloatField(), filter=None, **extra)
# 返回给定expression 的平均值，其中expression 必须为数值。
# 默认的别名：<field>__avg
# 返回类型：float
Count(expression, distinct=False, filter=None, **extra)
# 返回与expression 相关的对象的个数。distinct默认False，若为True，则将只计算唯一的实例
# 默认的别名：<field>__count
# 返回类型：int
Max(expression, output_field=None, filter=None, **extra)
# 返回expression 的最大值。
# 默认的别名：<field>__max
# 返回类型：与输入字段的类型相同，如果提供则为 output_field 类型
Min(expression, output_field=None, filter=None, **extra)
# 返回expression 的最小值
# 默认的别名：<field>__min
# 返回的类型：与输入字段的类型相同，如果提供则为 output_field 类型
StdDev(expression, sample=False, filter=None, **extra)
# 返回expression 的标准差。默认情况下，StdDev 返回群体的标准差。但是，如果sample=True，返回的值将是样本的标准差。
# 默认的别名：<field>__stddev
# 返回类型：float
Sum(expression, output_field=None, filter=None, **extra)
# 计算expression 的所有值的和。
# 默认的别名：<field>__sum
# 返回类型：与输入的字段相同，如果提供则为output_field 的类型
Variance(expression, sample=False, filter=None, **extra)
# 返回expression 的方差。默认情况下，Variance 返回群体的方差。但是，如果sample=True，返回的值将是样本的方差。
# 默认的别名：<field>__variance
# 返回的类型：float

# 参数
expression  
# 引用模型字段的一个字符串，或者一个查询表达式。
output_field  
# 用来表示返回值的模型字段，它是一个可选的参数。在组合多个类型的字段时，只有在所有的字段都是相同类型的情况下，Django 才能确定output_field。否则，你必须自己提供output_field 参数。
filter
# 2.0新增，一个可选的Q对象，用于过滤聚合的行
**extra
# 这些关键字参数可以给聚合函数生成的SQL 提供额外的信息。
```

### 查询pk

为了方便，Django 提供一个查询快捷方式`pk` ，它表示“primary key” 的意思

```shell
# 精确查询
>>> Blog.objects.get(id__exact=14) # Explicit form
>>> Blog.objects.get(id=14) # __exact is implied
>>> Blog.objects.get(pk=14) # pk implies id__exact
# 与其他类型结合
# Get blogs entries with id 1, 4 and 7
>>> Blog.objects.filter(pk__in=[1,4,7])
# Get all blog entries with id > 14
>>> Blog.objects.filter(pk__gt=14)
# 在join中工作
>>> Entry.objects.filter(blog__id__exact=3) # Explicit form
>>> Entry.objects.filter(blog__id=3)        # __exact is implied
>>> Entry.objects.filter(blog__pk=3)        # __pk implies __id__exact
```

### 转义like语句中的`%,_`

与`LIKE` SQL 语句等同的字段查询（`iexact`、`contains`、`icontains`、`startswith`、`istartswith`、`endswith` 和`iendswith`）将自动转义在`LIKE` 语句中使用的两个特殊的字符 —— 百分号和下划线。（在`LIKE` 语句中，百分号通配符表示多个字符，下划线通配符表示单个字符）。

```python
# 查询
>>> Entry.objects.filter(headline__contains='%')
# django自动转义为类似如下的SQL
SELECT ... WHERE headline LIKE '%\%%';
```

### 查询表达式

```
表达式定义在django.db.models.expressions 和 django.db.models.aggregates中, 但为了方便，通常可以直接从django.db.models导入.
```

#### F

一个 `F()`对象代表了一个model的字段值或注释列。它会生成一个SQL表达式。优点如下

```
1. 直接通过数据库操作而不是python
2. 减少数据库查询次数
3. 可避免竞态条件，保证字段的值为当前最新
```

使用它就可以直接参考model的field和执行数据库操作而不用再把它们（model field）查询出来放到python内存中

```python
# Tintin filed a news story!
reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed += 1  # 从数据库取出放到内存中并用我们熟悉的python运算符操作它
reporter.save()

# F方法
from django.db.models import F

reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed = F('stories_filed') + 1  # SQL实时数据
reporter.save()

# 要访问以这种方式保存的新值，必须重新加载该对象：
reporter = Reporters.objects.get(pk=reporter.pk)
# Or, more succinctly:
reporter.refresh_from_db()

# 在Model.save()后F()仍存在
reporter = Reporters.objects.get(name='Tintin')
reporter.stories_filed = F('stories_filed') + 1
reporter.save()

reporter.name = 'Tintin Jr.'
reporter.save()  # stories_filed被更新2次，若初始值为1，此时为3
```

- update

```shell
>>> Entry.objects.all().update(n_pingbacks=F('n_pingbacks') + 1)  # ok，批量更新
# THIS WILL RAISE A FieldError
>>> Entry.objects.update(headline=F('blog__name'))  # fail,不可引入join
```

- filter

`F()` 返回的实例用作查询内部对模型字段的引用。这些引用可以用于查询的filter 中来比较相同模型实例上不同字段之间值的比较。

```shell
>>> from django.db.models import F
>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks'))
```

Django 支持对`F()` 对象使用加法、减法、乘法、除法、取模以及幂计算等算术操作，两个操作数可以都是常数和其它`F()` 对象。

```shell
>>> Entry.objects.filter(n_comments__gt=F('n_pingbacks') * 2)
>>> Entry.objects.filter(rating__lt=F('n_comments') + F('n_pingbacks'))
>>> from datetime import timedelta
>>> Entry.objects.filter(mod_date__gt=F('pub_date') + timedelta(days=3))
```

可以在`F()` 对象中使用双下划线标记来跨越关联关系。带有双下划线的`F()` 对象将引入任何需要的join 操作以访问关联的对象

```shell
>>> Entry.objects.filter(authors__name=F('blog__name'))
```

`F()` 对象支持`.bitand()` 和`.bitor()` 两种位操作

```shell
>>> F('somefield').bitand(16)
```

- annotate

```python
# 通过将不同字段与算术相结合来在模型上创建动态字段
company = Company.objects.annotate(chairs_needed=F('num_employees') - F('num_chairs'))

# 如果你组合的字段是不同类型，你需要告诉Django将返回什么类型的字段。由于F()不直接支持output_field，您需要使用ExpressionWrapper
from django.db.models import DateTimeField, ExpressionWrapper, F

Ticket.objects.annotate(
    expires=ExpressionWrapper(
        F('active_at') + F('duration'), output_field=DateTimeField()))

# 引用诸如ForeignKey之类的关系字段时，F（）返回主键值而不是模型实例
>> car = Company.objects.annotate(built_by=F('manufacturer'))[0]
>> car.manufacturer
<Manufacturer: Toyota>
>> car.built_by
3
```

#### Func

`Func()` 表达式是所有表达式的基础类型，包括数据库函数如 `COALESCE` 和 `LOWER`, 或者 `SUM`聚合

```python
# 方法一：直接使用
from django.db.models import Func, F
queryset.annotate(field_lower=Func(F('field'), function='LOWER'))

# 方法二：用于构建数据库函数库
class Lower(Func):
    function = 'LOWER'
queryset.annotate(field_lower=Lower(F('field')))

# 均生成类似SQL
select ... LOWER('db_table')
```

- API

```python
Class Func(*expression, **extra)

# 参数
*expression  # 是函数将应用于的位置表达式列表。表达式将转换为字符串，与arg_joiner连接在一起，然后作为expressions占位符插入到template中。位置参数可以是表达式或Python值。字符串被假定为列引用，将包装在F（）表达式中，而其他值将包装在Value（）表达式中。
**extra  # 是key=value键值对，可以插入到template属性中。为避免SQL注入漏洞，extra不得包含不受信任的用户输入，因为这些值会插入到SQL字符串中，而不是作为查询参数传递，数据库驱动程序会将其转义。 
function,template,arg_joiner关键字可用于替换同名的属性，而无需定义自己的类。
output_field可用于定义预期的返回类型
```

属性

```python
function  
# 类属性，描述将生成的函数。具体来说，函数将作为template中的function占位符进行插值。默认None
template  
# 类属性，作为格式字符串，描述为此函数生成的SQL。默认为'%(function)s(%(expressions)s)'。如果你正在构建像strftime('%W', 'date')这样的SQL并且在查询中需要一个文字％字符，那么在模板属性中将它翻两倍（%%%%），因为字符串被插值两次：as_sql（）中的模板插值和SQL插值中的一次使用数据库游标中的查询参数。
arg_joiner
# 类属性，表示用于将表达式列表连接在一起的字符。默认为','
arity
# 类属性，表示函数接收的参数个数。如果设置了此属性并且使用不同数量的表达式调用函数，则将引发TypeError。默认为None
```

方法

```python
as_sql(compiler, connection, function=None, template=None, arg_joiner=None, **extra_context)
# 为数据库函数生成SQL

# as_vendor()方法应该用 function, template, arg_joiner和其他**extra_context 来按照需要自定义SQL
class ConcatPair(Func):
    ...
    function = 'CONCAT'
    ...

    def as_mysql(self, compiler, connection):
        return super().as_sql(
            compiler, connection,
            function='CONCAT_WS',
            template="%(function)s('', %(expressions)s)",
        )
```

#### Aggregate

`Aggregate()`表达式是`Func()`表达式的一个特例，它通知查询需要`GROUP BY`子句。所有的聚合函数，类似`Sum(),Count()`，均继承自`Aggregate()`

```python
# 由于Aggregates是表达式和包装表达式，可以表示一些复杂的计算
from django.db.models import Count

Company.objects.annotate(
    managers_required=(Count('num_employees') / 4) + Count('num_managers'))
```

- API

```python
class Aggregate(expression, output_field=None, filter=None, **extra)

# 参数
expression  # 可以是模型上的字段名称，也可以是其他表达式。它将转换为字符串并用作template中的expressions占位符
output_field  # output_field参数需要一个模型字段实例，如IntegerField()或BooleanField()，Django将在从数据库中检索后加载该值。通常在实例化模型字段时不需要参数，因为不会对表达式的输出值(max_length，max_digits等)强制执行与数据验证相关的任何参数。注意：只有当Django无法确定结果应该是什么字段类型时才需要output_field。混合字段类型的复杂表达式应定义所需的output_field。例如，将IntegerField（）和FloatField（）放在一起应该可以定义output_field = FloatField（）。
filter  # filter参数采用Q对象，该对象用于过滤聚合的行
**extra  # 是可以插入到template的键值对
```

属性

```python
template
# 类属性，作为格式字符串，描述为此函数生成的SQL。默认为'%(function)s(%(expressions)s)'。
function
# 类属性，描述将要生成的聚合函数。具体来说，函数将作为template中的function占位符进行插值。默认None
window_compatible
# 默认为True，因为大多数聚合函数都可以用作Window中的源表达式。
```

- 自定义Aggregate函数

```python
from django.db.models import Aggregate

class Count(Aggregate):
    # supports COUNT(distinct field)
    function = 'COUNT'
    template = '%(function)s(%(distinct)s%(expressions)s)'

    def __init__(self, expression, distinct=False, **extra):
        super().__init__(
            expression,
            distinct='DISTINCT ' if distinct else '',
            output_field=IntegerField(),
            **extra
        )
```

#### Value

```
class Value(value, output_field=None)
```

`Value()`对象表示表达式的最小可能组件：简单值。当您需要表示表达式中的整数，布尔值或字符串的值时，可以将该值包装在`Value()`中。

很少需要直接使用`value()`，当使用表达式`F('field')+1`，Django隐式地将1包装在`value()`中，允许在更复杂的表达式中使用简单值。如果要将字符串传递给表达式，则需要使用`Value()`。大多数表达式将字符串参数解释为字段的名称，如`Lower('name')`

value参数描述要包含在表达式中的值，例如1，True或None。Django知道如何将这些Python值转换为相应的数据库类型。

`output_field`参数应该是一个模型字段实例，如`IntegerField()`或`BooleanField()`，Django将在从数据库中检索后加载该值。通常在实例化模型字段时不需要参数，因为不会对表达式的输出值`(max_length，max_digits等)`强制执行与数据验证相关的任何参数。

#### ExpressionWrapper

```python
class ExpressionWrapper(expression, output_field)
```

`ExpressionWrapper`仅仅是对其他的表达式进行包裹，提供对其他表达式可能无法使用的属性(如output_field)的访问。

对于不同类型的`F()`表达式的数学计算，`ExpressionWrapper`是必须的。

#### Condition

在 `filters,annotations,aggregations,updates`中可以使用`if...elif...else`。条件表达式计算表的每一行的一系列条件，并返回匹配的结果表达式。条件表达式也可以像其他表达式一样组合和嵌套。

```python
from django.db import models

class Client(models.Model):
    REGULAR = 'R'
    GOLD = 'G'
    PLATINUM = 'P'
    ACCOUNT_TYPE_CHOICES = (
        (REGULAR, 'Regular'),
        (GOLD, 'Gold'),
        (PLATINUM, 'Platinum'),
    )
    name = models.CharField(max_length=50)
    registered_on = models.DateField()
    account_type = models.CharField(
        max_length=1,
        choices=ACCOUNT_TYPE_CHOICES,
        default=REGULAR,
    )
```

- When

```
class When(condition=None, then=None, **lookups)
```

`When()`对象用于封装条件及其结果以在条件表达式中使用。使用`When()`对象类似于使用`filter()`方法。可以使用字段查找或Q对象指定条件。结果使用then关键字提供。

```shell
>>> from django.db.models import When, F, Q
>>> # String arguments refer to fields; the following two examples are equivalent:
>>> When(account_type=Client.GOLD, then='name')
>>> When(account_type=Client.GOLD, then=F('name'))
>>> # You can use field lookups in the condition
>>> from datetime import date
>>> When(registered_on__gt=date(2014, 1, 1),
...      registered_on__lt=date(2015, 1, 1),
...      then='account_type')
>>> # Complex conditions can be created using Q objects
>>> When(Q(name__startswith="John") | Q(name__startswith="Paul"),
...      then='name')
```

由于then关键字参数是为When（）的结果保留的，因此如果Model有一个名为then的字段，则存在潜在的冲突。这可以通过两种方式解决

```shell
>>> When(then__exact=0, then=1)
>>> When(Q(then=0), then=1)
```

- case

```
class Case(*cases, **extra)
```

`Case()`表达式类似于Python中的if ... elif ... else语句。提供的`When()`对象中的每个条件按顺序计算，直到一个求值为真值。返回匹配的`When()`对象的结果表达式。

```shell
>>>
>>> from datetime import date, timedelta
>>> from django.db.models import CharField, Case, Value, When
>>> Client.objects.create(
...     name='Jane Doe',
...     account_type=Client.REGULAR,
...     registered_on=date.today() - timedelta(days=36))
>>> Client.objects.create(
...     name='James Smith',
...     account_type=Client.GOLD,
...     registered_on=date.today() - timedelta(days=5))
>>> Client.objects.create(
...     name='Jack Black',
...     account_type=Client.PLATINUM,
...     registered_on=date.today() - timedelta(days=10 * 365))
>>> # Get the discount for each Client based on the account type
>>> Client.objects.annotate(
...     discount=Case(
...         When(account_type=Client.GOLD, then=Value('5%')),
...         When(account_type=Client.PLATINUM, then=Value('10%')),
...         default=Value('0%'),
...         output_field=CharField(),
...     ),
... ).values_list('name', 'discount')
<QuerySet [('Jane Doe', '0%'), ('James Smith', '5%'), ('Jack Black', '10%')]>
```

`Case()`接受任意数量的`When()`对象作为单独的参数。使用关键字参数提供其他选项。如果没有条件评估为TRUE，则返回使用default关键字参数给出的表达式。如果未提供默认参数，则使用None。

如果我们想根据客户与我们在一起的时间来更改我们之前的查询以获得折扣，我们可以使用查找来执行此操作：

```shell
>>> a_month_ago = date.today() - timedelta(days=30)
>>> a_year_ago = date.today() - timedelta(days=365)
>>> # Get the discount for each Client based on the registration date
>>> Client.objects.annotate(
...     discount=Case(
...         When(registered_on__lte=a_year_ago, then=Value('10%')),
...         When(registered_on__lte=a_month_ago, then=Value('5%')),
...         default=Value('0%'),
...         output_field=CharField(),
...     )
... ).values_list('name', 'discount')
<QuerySet [('Jane Doe', '5%'), ('James Smith', '0%'), ('Jack Black', '10%')]>
```

case+filter

```shell
# 找到一个多月前注册的黄金客户和一年多前注册的白金客户
>>> a_month_ago = date.today() - timedelta(days=30)
>>> a_year_ago = date.today() - timedelta(days=365)
>>> Client.objects.filter(
...     registered_on__lte=Case(
...         When(account_type=Client.GOLD, then=a_month_ago),
...         When(account_type=Client.PLATINUM, then=a_year_ago),
...     ),
... ).values_list('name', 'account_type')
<QuerySet [('Jack Black', 'P')]>
```

- update

```shell
# 假设我们想要更改客户的account_type以匹配其注册日期。我们可以使用条件表达式和update（）方法来完成此操作
>>> a_month_ago = date.today() - timedelta(days=30)
>>> a_year_ago = date.today() - timedelta(days=365)
>>> # Update the account_type for each Client from the registration date
>>> Client.objects.update(
...     account_type=Case(
...         When(registered_on__lte=a_year_ago,
...              then=Value(Client.PLATINUM)),
...         When(registered_on__lte=a_month_ago,
...              then=Value(Client.GOLD)),
...         default=Value(Client.REGULAR)
...     ),
... )
>>> Client.objects.values_list('name', 'account_type')
<QuerySet [('Jane Doe', 'G'), ('James Smith', 'R'), ('Jack Black', 'P')]>
```

- aggregation

```shell
# 如果我们想知道每个account_type有多少客户端怎么办？我们可以使用聚合函数的filter参数来实现这个目的
>>> # Create some more Clients first so we can have something to count
>>> Client.objects.create(
...     name='Jean Grey',
...     account_type=Client.REGULAR,
...     registered_on=date.today())
>>> Client.objects.create(
...     name='James Bond',
...     account_type=Client.PLATINUM,
...     registered_on=date.today())
>>> Client.objects.create(
...     name='Jane Porter',
...     account_type=Client.PLATINUM,
...     registered_on=date.today())
>>> # Get counts for each value of account_type
>>> from django.db.models import Count
>>> Client.objects.aggregate(
...     regular=Count('pk', filter=Q(account_type=Client.REGULAR)),
...     gold=Count('pk', filter=Q(account_type=Client.GOLD)),
...     platinum=Count('pk', filter=Q(account_type=Client.PLATINUM)),
... )
{'regular': 2, 'gold': 1, 'platinum': 3}
```

类似SQL

```sql
SELECT count(CASE WHEN account_type=1 THEN id ELSE null) as regular,
       count(CASE WHEN account_type=2 THEN id ELSE null) as gold,
       count(CASE WHEN account_type=3 THEN id ELSE null) as platinum
FROM clients;
```

#### Subquery

```python
class Subquery(queryset, output_field=None)
```

可以使用Subquery表达式向QuerySet添加显式子查询

```shell
# 要使用该帖子上最新评论的作者的电子邮件地址来注释每个帖子
>>> from django.db.models import OuterRef, Subquery
>>> newest = Comment.objects.filter(post=OuterRef('pk')).order_by('-created_at')
>>> Post.objects.annotate(newest_commenter_email=Subquery(newest.values('email')[:1]))
```

- OuterRef

```
class OuterRef(field)
```

当子查询中的查询集需要引用外部查询中的字段时，请使用OuterRef。它的作用类似于F表达式，除了在解析外部查询集之前不会检查它是否引用有效字段。OuterRef的实例可以与子查询的嵌套实例结合使用，以引用不是直接父级的包含查询集。

```shell
# 此查询集需要位于嵌套的子查询实例对中才能解析纠正
>>> Book.objects.filter(author=OuterRef(OuterRef('pk')))
```

- 将子查询限制为单个列

有时必须从子查询返回单个列，例如，使用子查询作为__in查找的目标

```shell
# 要返回上一天发布的帖子的所有评论
>>> from datetime import timedelta
>>> from django.utils import timezone
>>> one_day_ago = timezone.now() - timedelta(days=1)
>>> posts = Post.objects.filter(published_at__gte=one_day_ago)
>>> Comment.objects.filter(post__in=Subquery(posts.values('pk')))
```

- 将子查询限制为单行

```shell
# 使用[:1]来从多行中获得单行的子查询
>>> subquery = Subquery(newest.values('email')[:1])
>>> Post.objects.annotate(newest_commenter_email=subquery)
# 使用get()而不是切片会失败，因为在子查询中使用查询集之前无法解析OuterRef。
```

- Exists

```python
class Exists(queryset)
```

Exists是一个使用SQL EXISTS语句的子查询子类。在许多情况下，它将比子查询执行得更好，因为数据库能够在找到第一个匹配行时停止对子查询的评估。

```shell
# 使用是否在最后一天内发表评论来对每个帖子进行注释
>>> from django.db.models import Exists, OuterRef
>>> from datetime import timedelta
>>> from django.utils import timezone
>>> one_day_ago = timezone.now() - timedelta(days=1)
>>> recent_comments = Comment.objects.filter(
...     post=OuterRef('pk'),
...     created_at__gte=one_day_ago,
... )
>>> Post.objects.annotate(recent_comment=Exists(recent_comments))
```

没有必要强制Exists引用单个列，因为列被丢弃并返回布尔结果。同样，由于在SQL EXISTS子查询中排序并不重要，只会降低性能，因此会自动删除

- filter

```shell
# 直接操作，有误
>>> Post.objects.filter(Exists(recent_comments))
...
TypeError: 'Exists' object is not iterable
# annotate
>>> Post.objects.annotate(
...     recent_comment=Exists(recent_comments),
... ).filter(recent_comment=True)
```

- aggregate

聚合可以在子查询中使用，但它们需要`filter()，values()和annotate()`的特定组合才能使子查询分组正确。

```shell
# 假设两个模型都有一个长度字段，找到帖子长度大于所有组合评论总长度的帖子
>>> from django.db.models import OuterRef, Subquery, Sum
>>> comments = Comment.objects.filter(post=OuterRef('pk')).order_by().values('post')
>>> total_comments = comments.annotate(total=Sum('length')).values('total')
>>> Post.objects.filter(length__gt=Subquery(total_comments))
```

#### RawSQL

```
class RawSQL(sql, params, output_field=None)
```

有时数据库表达式不能轻易表达复杂的WHERE子句。在这些边缘情况下，使用Raw SQL表达式。

```shell
>>> from django.db.models.expressions import RawSQL
>>> queryset.annotate(val=RawSQL("select col from sometable where othercol = %s", (someparam,)))
```

#### Window

窗口函数提供了一种在分区上应用函数的方法。与计算由组定义的每个集合的最终结果的常规聚合函数不同，窗口函数对帧和分区进行操作，并计算每行的结果。

您可以在同一查询中指定多个窗口，这些窗口在Django ORM中等效于在QuerySet.annotate（）调用中包含多个表达式。ORM不使用命名窗口，而是它们是所选列的一部分

```python
class Window(expression, partition_by=None, order_by=None, frame=None, output_field=None)
# Window类是OVER子句的主要表达式。

# 属性
filterable  # 默认为False。SQL标准不允许在WHERE子句中引用窗口函数，Django在构造可以执行此操作的QuerySet时引发异常。
template  # 默认%(expression)s OVER (%(window)s)'。如果仅提供表达式参数，则window子句将为空。
# 参数
expression  # 可以是window函数、aggregate函数、窗口子句中兼容的表达式
partition_by  # 是一个表达式列表（列名应包含在F对象中），用于控制行的分区。分区会缩小哪些行用于计算结果集。
output_field  # 指定为参数或表达式
order_by  # order_by参数接受一系列表达式，您可以在其上调用asc()和desc()。排序控制表达式的应用顺序
frame  # 指定应在计算中使用的其他行
```

例如，用相同类型的同一个工作室为电影的平均评级注释每部电影，然后发布

```shell
>>> from django.db.models import Avg, F, Window
>>> from django.db.models.functions import ExtractYear
>>> Movie.objects.annotate(
>>>     avg_rating=Window(
>>>         expression=Avg('rating'),
>>>         partition_by=[F('studio'), F('genre')],
>>>         order_by=ExtractYear('released').asc(),
>>>     ),
>>> )
```

在同一窗口上应用多个表达式，即相同的分区和帧。

```shell
# 您可以通过在同一查询中使用三个窗口函数来修改前一个示例，以包括每个电影组（同一工作室，流派和发行年份）中的最佳和最差评级。将前一个示例中的分区和排序提取到字典中以减少重复
>>> from django.db.models import Avg, F, Max, Min, Window
>>> from django.db.models.functions import ExtractYear
>>> window = {
>>>    'partition_by': [F('studio'), F('genre')],
>>>    'order_by': ExtractYear('released').asc(),
>>> }
>>> Movie.objects.annotate(
>>>     avg_rating=Window(
>>>         expression=Avg('rating'), **window,
>>>     ),
>>>     best=Window(
>>>         expression=Max('rating'), **window,
>>>     ),
>>>     worst=Wsindow(
>>>         expression=Min('rating'), **window,
>>>     ),
>>> )
```

- Frames

对于窗口框架，您可以选择基于范围的行序列或普通的行序列。

```python
class ValueRange(start=None, end=None)
# 属性
frame_type  # 设置到'RANGE'
class RowRange(start=None, end=None)
# 属性
frame_type  # 设置为'ROWS'

# 两个类均返回如下样式SQL
%(frame_type)s BETWEEN %(start)s AND %(end)s
```

示例

```shell
# 如果电影的“同伴”被描述为同一个同一个工作室在同一年中发布的电影，则此RowRange示例使用电影的两个先前和后两个对等体的平均评级来注释每个电影
>>> from django.db.models import Avg, F, RowRange, Window
>>> from django.db.models.functions import ExtractYear
>>> Movie.objects.annotate(
>>>     avg_rating=Window(
>>>         expression=Avg('rating'),
>>>         partition_by=[F('studio'), F('genre')],
>>>         order_by=ExtractYear('released').asc(),
>>>         frame=RowRange(start=-2, end=2),
>>>     ),
>>> )

# 如果数据库支持它，则可以根据分区中表达式的值指定起点和终点。如果电影模型的已发布字段存储每部电影的发布月份，则此ValueRange示例使用每部电影之前12个月和之后12个月之间发布的电影同伴的平均评级来注释每部电影。
>>> from django.db.models import Avg, ExpressionList, F, ValueRange, Window
>>> Movie.objects.annotate(
>>>     avg_rating=Window(
>>>         expression=Avg('rating'),
>>>         partition_by=[F('studio'), F('genre')],
>>>         order_by=F('released').asc(),
>>>         frame=ValueRange(start=-12, end=12),
>>>     ),
>>> )
```



###  查询相关的类

#### Q

`Q()` 对象用于封装一组关键字参数。这些关键字参数就是“字段查询” 中所提及的那些。

`Q` 对象可以使用`&` 求和，使用`|` 操作符组求或，使用`~` 操作符取反，允许组合操作。当一个操作符在两个`Q` 对象上使用时，它产生一个新的`Q` 对象

```python
from django.db.models import Q
# 或
list = BookInfo.objects.filter(Q(bread__gt=20) | Q(pk__lt=3))
# 非
list = BookInfo.objects.filter(~Q(pk=3))
# 与
BookInfo.objects.filter(bread_gt=20,id_lt=3)
BookInfo.objects.filter(bread_gt=20).filter(id_lt=3)
BookInfo.objects.filter(Q(bread_gt=20)&(id_lt=3))
# 多个Q对象参数，逻辑关系为AND
Poll.objects.get(Q(question__startswith='Who'),Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)))
# 混合关键字和Q对象，但是Q对象必须置前
Poll.objects.get(Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)), question__startswith='Who')
```

#### Prefetch

通常，Prefetch() 对象能够用于控制prefetch_related( )的操作.

```python
class Prefetch(lookup, queryset=None, to_attr=None)

# lookup参数描述了跟随的关系，并且工作方式与传递给prefetch_related()的基于字符串的查找相同。
# queryset参数为给定的查找提供基本QuerySet。这对于进一步过滤预取操作或从预取关系调用select_related()很有用，因此进一步减少查询数量
# to_attr参数将预取操作的结果设置为自定义属性。当使用to_attr时，预取的结果存储在列表中。这可以提供比存储在QuerySet实例内的缓存结果的传统prefetch_related调用显着的速度改进。
```

示例

```shell
# lookup
>>> Question.objects.prefetch_related(Prefetch('choice_set')).get().choice_set.all()
[<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
# This will only execute two queries regardless of the number of Question
# and Choice objects.
>>> Question.objects.prefetch_related(Prefetch('choice_set')).all()
[<Question: Question object>]

# queryset
>>> voted_choices = Choice.objects.filter(votes__gt=0)
>>> voted_choices
[<Choice: The sky>]
>>> prefetch = Prefetch('choice_set', queryset=voted_choices)
>>> Question.objects.prefetch_related(prefetch).get().choice_set.all()
[<Choice: The sky>]

# to_attr
>>> prefetch = Prefetch('choice_set', queryset=voted_choices, to_attr='voted_choices')
>>> Question.objects.prefetch_related(prefetch).get().voted_choices
[<Choice: The sky>]
>>> Question.objects.prefetch_related(prefetch).get().choice_set.all()
[<Choice: Not much>, <Choice: The sky>, <Choice: Just hacking again>]
```

#### prefetch_related_objects

在可迭代的模型实例上预取给定的查找。这在接收模型实例列表而不是QuerySet的代码中很有用;例如，从缓存中获取模型或手动实例化它们时。2.0中新增

```python
prefetch_related_objects(model_instances, *related_lookups)

# 传递一个可迭代的模型实例（必须都是同一个类）以及要预取的查找或预取对象
```

示例

```shell
>>> from django.db.models import prefetch_related_objects
>>> restaurants = fetch_top_restaurants_from_cache()  # A list of Restaurants
>>> prefetch_related_objects(restaurants, 'pizzas__toppings')
```

#### FilteredRelation

FilteredRelation与`annotate（）`一起使用，以在执行JOIN时创建ON子句。它不作用于默认关系，而是作用于注释名称（下面的示例中为pizzas_vegetarian）。2.0新增

```python
FilteredRelation(relation_name, *, condition=Q())[source]

# relation_name参数：要过滤关系的字段的名称。
# condition参数：用于控制过滤的Q对象。
```

不支持如下场景

```python
# 1.跨越关系段的条件
>>> Restaurant.objects.annotate(
...    pizzas_with_toppings_startswith_n=FilteredRelation(
...        'pizzas__toppings',
...        condition=Q(pizzas__toppings__name__startswith='n'),
...    ),
... )
Traceback (most recent call last):
...
ValueError: FilteredRelation's condition doesn't support nested relations (got 'pizzas__toppings__name__startswith').
# 2. QuerySet.only() and prefetch_related()
# 3. 从父模型继承的GenericForeignKey
```

示例

```shell
>>> from django.db.models import FilteredRelation, Q
>>> Restaurant.objects.annotate(
...    pizzas_vegetarian=FilteredRelation(
...        'pizzas', condition=Q(pizzas__vegetarian=True),
...    ),
... ).filter(pizzas_vegetarian__name__icontains='mozzarella')

# 大量数据，以下更优
>>> Restaurant.objects.filter(
...     pizzas__vegetarian=True,
...     pizzas__name__icontains='mozzarella',
... )
```



## 关联的对象

当你在一个模型中定义一个关联关系时（例如，`ForeignKey`、 `OneToOneField`或`ManyToManyField`），该模型的实例将带有一个方便的API 来访问关联的对象。

### 一对多

- 前向查询

若一个模型具有ForeignKey，则该模型将可以通过属性访问关联的对象

```python
>>> e = Entry.objects.get(id=2)
>>> e.blog # Returns the related Blog object.
```

可以通过外键属性获取和设置

```shell
>>> e = Entry.objects.get(id=2)
>>> e.blog = some_blog
>>> e.save()
# 如果ForeignKey字段有null=True设置（即它允许NULL 值），你可以分配None来删除对应的关联性。
>>> e = Entry.objects.get(id=2)
>>> e.blog = None
>>> e.save() # "UPDATE blog_entry SET blog_id = NULL ...;"
```

一对多关联关系的前向访问在第一次访问关联的对象时被缓存。以后对同一个对象的外键的访问都使用缓存。

```shell
>>> e = Entry.objects.get(id=2)
>>> print(e.blog)  # Hits the database to retrieve the associated Blog.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.

# 注意select_related() 查询集方法递归地预填充所有的一对多关系到缓存中
>>> e = Entry.objects.select_related().get(id=2)
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
```

- 反向查询

果一个模型有一个`ForeignKey`，那么外键模型的实例将有权访问返回前一个模型的所有实例的`Manager`。 默认情况下，`Manager`被命名为`FOO_set`，其中`FOO`是小写的源模型名称。 这个`Manager`返回`QuerySets`，它可以进行过滤和操作。

```shell
>>> b = Blog.objects.get(id=1)
>>> b.entry_set.all() # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
>>> b.entry_set.filter(headline__contains='Lennon')
>>> b.entry_set.count()

# 可覆盖foo_set名称，使用related_name
# 如果Entry 模型改成blog = ForeignKey(Blog, related_name='entries')
>>> b = Blog.objects.get(id=1)
>>> b.entries.all() # Returns all Entry objects related to Blog.
# b.entries is a Manager that returns QuerySets.
>>> b.entries.filter(headline__contains='Lennon')
>>> b.entries.count()
```

自定义反向管理器

```python
# 默认情况下，用于反向关系的RelatedManager是该模型的默认管理器的子类。 
# 如果要为给定查询指定其他管理器,可如下定义
from django.db import models

class Entry(models.Model):
    #...
    objects = models.Manager()  # Default Manager
    entries = EntryManager()    # Custom Manager

b = Blog.objects.get(id=1)
b.entry_set(manager='entries').all()

# 如果EntryManager 在它的get_queryset()方法中使用默认的过滤，那么该过滤将适用于all()调用
# 指定一个自定义的管理器还可以让你调用自定义的方法
b.entry_set(manager='entries').is_published()
```

### 多对多

多对多关系的两端都会自动获得访问另一端的API。这些API 的工作方式与上面提到的“方向”一对多关系一样。

唯一的区别在于属性的名称：定义 `ManyToManyField`的模型使用该字段的属性名称，而“反向”模型使用源模型的小写名称加上`'_set'` （和一对多关系一样）

```python
e = Entry.objects.get(id=3)
e.authors.all() # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains='John')

a = Author.objects.get(id=5)
a.entry_set.all() # Returns all Entry objects for this Author.


# 类似ForeignKey，ManyToManyField 可以指定related_name。在上面的例子中，如果Entry 中的ManyToManyField 指定related_name='entries'，那么Author 实例将使用 entries 属性而不是entry_set。
```

### 一对一

一对一关系与多对一关系非常相似。

- 正向

如果你在模型中定义一个`OneToOneField`，该模型的实例将可以通过该模型的一个简单属性访问关联的模型。

```python
class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry)
    details = models.TextField()

ed = EntryDetail.objects.get(id=2)
ed.entry # Returns the related Entry object.
```

- 反向

在“反向”查询中有所不同。一对一关系中的关联模型同样具有一个`管理器`对象，但是该`管理器`表示一个单一的对象而不是对象的集合

```python
e = Entry.objects.get(id=2)
e.entrydetail # returns the related EntryDetail object

# 如果没有对象赋值给这个关联关系，Django 将引发一个DoesNotExist 异常。

# 实例可以赋值给反向的关联关系，方法和正向的关联关系一样
e.entrydetail = ed
```

### 反向关联的实现

其它对象关系映射要求你在关联关系的两端都要定义。Django 的开发人员相信这是对DRY（不要重复你自己的代码）原则的违背，所以Django 只要求你在一端定义关联关系。

但是这怎么可能？因为一个模型类直到其它模型类被加载之后才知道哪些模型类是关联的。

答案在`app registry` 中。当Django 启动时，它导入`INSTALLED_APPS`中列出的每个应用，然后导入每个应用中的`models` 模块。每创建一个新的模型时，Django 添加反向的关系到所有关联的模型。如果关联的模型还没有导入，Django 将保存关联关系的记录并在最终关联的模型导入时添加这些关联关系。

由于这个原因，你使用的所有模型都定义在`INSTALLED_APPS` 列出的应用中就显得特别重要。否则，反向的关联关系将不能正确工作。

### 通过关联的对象进行查询

在关联对象字段上的查询与正常字段的查询遵循同样的规则。当你指定查询需要匹配的一个值时，你可以使用一个对象实例或者对象的主键的值。

```python
# 如果你有一个id=5 的Blog对象b，下面的三个查询将是完全一样的
Entry.objects.filter(blog=b) # Query using object instance
Entry.objects.filter(blog=b.id) # Query using id from instance
Entry.objects.filter(blog=5) # Query using id directly
```

### 跨关联关系查询

查询中的关联关系，Django会在后台自动帮你处理`JOIN`。若要跨越关联关系，只需使用关联的模型字段的名称，并使用双下划线分隔，直至你想要的字段。这种跨越可以是任意的深度

```shell
>>> Entry.objects.filter(blog__name='Beatles Blog')
```

若要引用一个“反向”的关系，只需要使用该模型的小写的名称。

```shell
>>> Blog.objects.filter(entry__headline__contains='Lennon')
```

如果你在多个关联关系直接过滤而且其中某个中介模型没有满足过滤条件的值，Django 将把它当做一个空的（所有的值都为`NULL`）但是合法的对象。这意味着不会有错误引发

```python
Blog.objects.filter(entry__authors__name='Lennon')
```

isnull使用

```python
Blog.objects.filter(entry__authors__name__isnull=True)
# 返回包括author的name为空,以及author的name不为空但entry的author为空的的Blog对象。
Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)
# 返回author的name为空，entry的author不为空的的Blog对象
```

### 跨越多值的查询

当你基于`ManyToManyField` 或反向的`ForeignKey`来过滤一个对象时，有两种不同种类的过滤器。考虑`Blog`/`Entry` 关联关系（`Blog` 和 `Entry` 是一对多的关系）。我们可能想找出headline为*“Lennon”* 并且pub_date为'2008'年的Entry。或者我们可能想查询headline为*“Lennon”* 的Entry或者pub_date为'2008'的Entry。因为实际上有和单个`Blog` 相关联的多个Entry，所以这两个查询在某些场景下都是有可能并有意义的。

`ManyToManyField`有类似的情况。例如，如果`Entry`有一个`ManyToManyField`叫做 `tags`，我们可能想找到tag 叫做*“music”* 和*“bands”* 的Entry，或者我们想找一个tag 名为*“music”* 且状态为*“public”*的Entry。

对于这两种情况，Django 有种一致的方法来处理`filter()`调用。一个`filter()` 调用中的所有参数会同时应用以过滤出满足所有要求的记录。接下来的`filter()`调用进一步限制对象集，但是对于多值关系，它们应用到与主模型关联的对象，而不是应用到前一个`filter()`调用选择出来的对象。

```python
# 假设这里有一个blog拥有一条包含'Lennon'的entries条目和一条来自2008的entries条目,但是没有一条来自2008并且包含"Lennon"的entries条目。
Blog.objects.filter(entry__headline__contains='Lennon', entry__pub_date__year=2008)  # 且，return None
Blog.objects.filter(entry__headline__contains='Lennon').filter(entry__pub_date__year=2008)  # 或，有一个blog
```

exclude与filter的实现并不同。单个`exclude()`调用中的条件不必引用同一个记录

```python
# 排除headline 中包含“Lennon”的Entry和在2008 年发布的Entry,但不是排除同时满足两个条件
Blog.objects.exclude(
    entry__headline__contains='Lennon',
    entry__pub_date__year=2008,
)
# 排除同时满足两个条件
Blog.objects.exclude(
    entry=Entry.objects.filter(
        headline__contains='Lennon',
        pub_date__year=2008,
    ),
)
```

## 对查询集求值

- 迭代

`queryset`是可迭代的，它在首次迭代查询集时执行实际的数据库查询

```python
for e in Entry.objects.all():
    print(e.headline)
```

如果您只想确定是否存在至少一个结果， 使用`exists()`更有效

- 切片

可以使用Python的数组切片语法对`QuerySet`进行切片。 对一个未求值的QuerySet进行切片操作通常返回另一个未求值的Queryset，但是如果你在切片操作时使用了“step”参数，那么Django就会执行数据库的查询，结果是返回一个列表。 切片已经求值过的`QuerySet`也会返回一个列表。

还要注意的是，即使切割的未计算的`查询集`返回另一个未计算的`查询集`，进一步修改它（例如，添加更多的过滤器，或修改排序）是不允许的，因为这不很好地转换为SQL，它也没有明确的含义。

- 序列化/缓存

如果你`Pickle`一个`查询集`，它将在Pickle 之前强制将所有的结果加载到内存中。Pickle 通常用于缓存之前，并且当缓存的查询集重新加载时，你希望结果已经存在随时准备使用（从数据库读取耗费时间，就失去了缓存的目的）。这意味着当你Unpickle`查询集`时，它包含Pickle 时的结果，而不是当前数据库中的结果。

如果此后你只想Pickle 必要的信息来从数据库重新创建`查询集`，可以Pickle`查询集`的`query` 属性。

然后你可以使用类似下面的代码重新创建原始的`查询集`（不用加载任何结果）

```python
>>> import pickle
>>> query = pickle.loads(s)     # Assuming 's' is the pickled string.
>>> qs = MyModel.objects.all()
>>> qs.query = query            # Restore the original 'query'.
```

注意：不能在不同版本的Django中使用pickles。不可用于归档的长期策略

- repr

一个`QuerySet`就等价于你使用`repr()`时的效果。 这会为你在python的交互式编译下提供方便，所以在你使用API交互的时候就会立马看到你的结果。

- len

你对`查询集`调用`len()` 时， 将对它求值。正如你期望的那样，返回一个查询结果集的长度。

注意：当求数量时，使用`count()`方法更合适

- list

对`查询集`调用`list()` 将强制对它求值

```python
entry_list = list(Entry.objects.all())
entry_id_list = list(Entry.objects.values_list('id', flat=True).order_by('id'))
```

- bool

测试一个`查询集`的布尔值，例如使用`bool()`、`or`、`and`或者`if` 语句将导致查询集的执行。如果至少有一个记录，则`查询集`为`True`，否则为`False`。

```python
if Entry.objects.filter(headline="Test"):
   print("There is at least one Entry with the headline Test")
```

注意：如果你需要知道是否存在至少一条记录（而不需要真实的对象），使用 `exists()`将更加高效。

## 比较对象

为了比较两个模型实例，只需要使用标准的Python 比较操作符，即双等于符号：`==`。在后台，它会比较两个模型主键的值。

```python
>>> some_entry == other_entry
>>> some_entry.id == other_entry.id
# 主键名无关
>>> some_obj == other_obj
>>> some_obj.name == other_obj.name
```

## 拷贝模型实例

无继承

```python
blog = Blog(name='My blog', tagline='Blogging is easy')
blog.save() # blog.pk == 1

blog.pk = None
blog.save() # blog.pk == 2
```

使用继承

```python
class ThemeBlog(Blog):
    theme = models.CharField(max_length=200)

django_blog = ThemeBlog(name='Django', tagline='Django is easy', theme='python')
django_blog.save() # django_blog.pk == 3


# 不拷贝关联对象
django_blog.pk = None
django_blog.id = None
django_blog.save() # django_blog.pk == 4
```

拷贝关联对象

```python
entry = Entry.objects.all()[0] # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry.save()
entry.authors = old_authors # saves new many2many relations
```





