# 概述

[官方文档](https://rasa.com/docs/rasa/)

Rasa 是一个开源机器学习框架，用于基于文本和语音的自动化对话。理解消息、保持对话并连接到消息通道和 API。

使用rasa，可以构建在如下频道上构建语境助手

```
Facebook Messenger
Slack
Google Hangouts
Webex Teams
Microsoft Bot Framework
Rocket.Chat
Mattermost
Telegram
Twilio
Your own custom conversational channels
```

或者构建语音助手

```
Alexa Skills
Google Home Actions
```

Rasa 可帮助您构建上下文助手，能够进行多次来回的分层对话。为了让人类与上下文助手进行有意义的交流，助手需要能够使用上下文来构建之前讨论过的事物——Rasa 使您能够构建可以以可扩展方式执行此操作的助手。

## 构建助手
版本v2.8.12
### 安装

- 快速安装

```shell
# 创建虚环境
python3 -m venv ./venv
source ./venv/bin/activate
# 安装Rasa
pip3 install -U --user pip
pip3 install rasa
# 创建新项目
rasa init
```

- 分步安装

```shell
# 1.安装python环境
# ubuntu
sudo apt update
sudo apt install python3-dev python3-pip
# mac
brew update
brew install python
# windows
C:\> pip3 install -U pip
# 2.虚环境
python3 -m venv ./venv
source ./venv/bin/activate
# 3.安装rasa
pip3 install -U --user pip
pip3 install rasa
```

- 从源码构建

```shell
curl -sSL https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py | python
git clone https://github.com/RasaHQ/rasa.git
cd rasa
poetry install
```

- 添加依赖

添加所有依赖

```shell
pip3 install rasa[full]
```

添加spacy依赖

```
pip3 install rasa[spacy]
python3 -m spacy download en_core_web_md
```

添加mitie依赖

```shell
# 1.安装mitie
pip3 install git+https://github.com/mit-nlp/MITIE.git
pip3 install rasa[mitie]
# 2.下载mitie模型
# 需要的文件是total_word_feature_extractor.dat
```

- 更新版本

```shell
pip3 install --upgrade rasa  # 更新最新版本
pip3 install rasa==1.8.3  # 下载特定版本
```

### 命令行

```shell
rasa init
# 使用示例训练数据、操作和配置文件创建一个新项目。
rasa train 
# 使用您的 NLU 数据和故事训练模型，将经过训练的模型保存在 ./models
rasa interactive 
# 开始交互式学习会话，通过与您的助手聊天来创建新的训练数据。
rasa shell
# 加载您的训练模型，并让您在命令行与助手聊天
rasa run 
# 使用您训练的模型启动服务器
rasa run actions
# 使用 Rasa SDK 启动动作服务
rasa visualize
# 生成故事的可视化表示
rasa test
# 在以 test_ 开头的任何文件上测试训练过的 Rasa 模型。
rasa data split nlu
# 以80/20 拆分 NLU 训练数据。
rasa data convert
# 在不同格式之间转换训练数据。
rasa data validate
# 检查domain、NLU 和对话数据是否存在不一致。
rasa export
# 将对话从跟踪器存储导出到事件代理。
rasa x
# 在本地启动 Rasa X
rasa -h 
# 显示所有可用的命令。
```

### 最佳实践

- 对话驱动

对话驱动开发 (CDD) 是倾听用户意见并利用这些见解改进 AI 助手的过程。这是聊天机器人开发的总体最佳实践方法。开发出色的 AI 助手具有挑战性，因为用户总是会说出您没有预料到的内容。 CDD 背后的原则是，在每次对话中，用户都用他们自己的话告诉您他们想要什么。通过在机器人开发的每个阶段练习 CDD，您可以让您的助手面向真实的用户语言和行为。

CDD 包括以下操作：
```
尽快与用户共享您的助手
定期查看对话
注释消息并将其用作 NLU 训练数据
测试您的助手是否始终如您所愿
跟踪助手失败时的行为和随着时间的推移衡量其性能
修复您的助手如何处理不成功的对话
```

CDD 不是一个线性过程；随着您开发和改进您的机器人，您将一遍又一遍地重复相同的操作。

- 生成nlu数据

cdd中为了获得好的nlu模型，需要：收集真实数据、尽快给测试人员分享。

避免意图混乱：将类似的意图分割为不同的实体来避免意图的混乱

提高实体识别：预训练的实体抽取器、正则表达式、查找表、同义词

处理边缘情况：拼写错误、定义范围外的意图

控制更新：将数据视为代码做版本控制

- 书写对话数据

设计stories：愉快路径与不愉快路径，在不愉路径设计时使用cdd而不是状态机更高效。

规则与stories：规则常用于：单轮对话、回退行为、表单。单轮对话使用规则，多轮对话使用stories。

管理对话流程：平衡是否使用插槽来影响对话，平衡实现分支逻辑来或增加插槽处理不同响应，使用 OR 语句和检查点，在stories中创建逻辑中断

处理上下文切换：使用规则、使用stories

管理对话数据文件：使用不同文件来管理不同类型的对话内容

使用互动学习：可以使用Rasa X进行交互式学习

### 对话模式

#### 闲聊和问答

- 更新配置，定义检索的意图和响应选择器

`config.yml`

```yaml
policies:
# other policies
- name: RulePolicy


pipeline:
  - name: WhitespaceTokenizer
  - name: RegexFeaturizer
  - name: LexicalSyntacticFeaturizer
  - name: CountVectorsFeaturizer
  - name: CountVectorsFeaturizer
    analyzer: char_wb
    min_ngram: 1
    max_ngram: 4
  - name: DIETClassifier
    epochs: 100
  - name: EntitySynonymMapper
  - name: ResponseSelector
    epochs: 100
    
pipeline:
# Other components
- name: ResponseSelector
  epochs: 100
  retrieval_intent: faq
- name: ResponseSelector
  epochs: 100
  retrieval_intent: chitchat
```

- 创建规则

`rules.yml`

```yaml
rules:
  - rule: respond to FAQs
    steps:
    - intent: faq
    - action: utter_faq
  - rule: respond to chitchat
    steps:
    - intent: chitchat
    - action: utter_chitchat
```

- 更新nlu训练数据

`nlu.yml`

```yaml
nlu:
  - intent: chitchat/ask_name
    examples: |
      - What is your name?
      - May I know your name?
      - What do people call you?
      - Do you have a name for yourself?
  - intent: chitchat/ask_weather
    examples: |
      - What's the weather like today?
      - Does it look sunny outside today?
      - Oh, do you mind checking the weather for me please?
      - I like sunny days in Berlin.
```

`domain.yml`

```yaml
intents:
# other intents
- chitchat
```

- 定义响应内容

`domain.yml`

```yaml
responses:
  utter_chitchat/ask_name:
  - image: "https://i.imgur.com/zTvA58i.jpeg"
    text: Hello, my name is Retrieval Bot.
  - text: I am called Retrieval Bot!
  utter_chitchat/ask_weather:
  - text: Oh, it does look sunny right now in Berlin.
    image: "https://i.imgur.com/vwv7aHN.png"
  - text: I am not sure of the whole week but I can see the sun is out today.
```

- 总结

```
将 RulePolicy 添加到您的策略中，并将 ResponseSelector 添加到您在 config.yml 中的管道
添加至少一项规则以响应常见问题/闲聊
添加常见问题解答/闲聊意图的示例
添加常见问题解答/闲聊意图的响应
更新您的意图领域
```

#### 处理业务逻辑

- 定义表单

`domain.yml`

```yaml
forms:  # 表单
  restaurant_form:
    required_slots:
        cuisine:
          - type: from_entity
            entity: cuisine
        num_people:
          - type: from_entity
            entity: number
        outdoor_seating:
          - type: from_intent
            intent: affirm
            value: true
          - type: from_intent
            intent: deny
            value: false
            
entities:  # 需要填充的实体插槽
  - cuisine
  - number   
  
slots: # 插槽
  cuisine:
    type: text
    auto_fill: false
    influence_conversation: false
  num_people:
    type: float
    auto_fill: false
    influence_conversation: false
  outdoor_seating:
    type: text
    auto_fill: false
    influence_conversation: false
      
responses:  # 响应插槽
  utter_ask_cuisine:
    - text: "What cuisine?"
  utter_ask_num_people:
    - text: "How many people?"
  utter_ask_outdoor_seating:
    - text: "Do you want to sit outside?"
```

`config.yml`

```yaml
language: en
pipeline:
# other components
- DucklingEntityExtractor:  # numbert提取器
  dimensions: ["number"]
```

- 更新配置

`config.yml`

```
policies:
  - name: RulePolicy
```

- 创建规则

`rules.yml`

```yaml
rules:
  - rule: activate restaurant form
    steps:
      - intent: request_restaurant   # intent that triggers form activation
      - action: restaurant_form      # run the form
      - active_loop: restaurant_form # this form is active

  - rule: submit form
    condition:
    - active_loop: restaurant_form   # this form must be active
    steps:
      - action: restaurant_form      # run the form
      - active_loop: null            # the form is no longer active because it has been filled
      - action: utter_submit         # action to take after the form is complete
      - action: utter_slots_values   # action to take after the form is complete
```

- 更新训练数据

```yaml
nlu:
- intent: request_restaurant
  examples: |
    - im looking for a restaurant
    - can i get [swedish](cuisine) food in any area
    - a restaurant that serves [caribbean](cuisine) food
    - id like a restaurant
    - im looking for a restaurant that serves [mediterranean](cuisine) food
    - can i find a restaurant that serves [chinese](cuisine)
    
- intent: affirm
  examples: |
    - Yes
    - yes, please
    - yup
    
- intent: deny
  examples: |
    - no don't
    - no
    - no I don't want that

- intent: inform
  examples: |
    - [afghan](cuisine) food
    - how bout [asian oriental](cuisine)
    - what about [indian](cuisine) food
    - uh how about [turkish](cuisine) type of food
    - um [english](cuisine)
    - im looking for [tuscan](cuisine) food
    - id like [moroccan](cuisine) food
    - for ten people
    - 2 people
    - for three people
    - just one person
    - book for seven people
    - 2 please
    - nine people
```

`domain.yml`

```yaml
intents:
  - request_restaurant
  - affirm
  - deny
  - inform
```

- 定义响应

`domain.yml`

```yaml
responses:
  utter_submit:
  - text: "All done!"
  utter_slots_values:
  - text: "I am going to run a restaurant search using the following parameters:\n
            - cuisine: {cuisine}\n
            - num_people: {num_people}\n
            - outdoor_seating: {outdoor_seating}"
```

- 总结

```
将 RulePolicy 添加到 config.yml
用域中的槽映射定义表单
将所有必需的槽添加到域
添加用于激活和提交表单的规则
添加用于激活表单的意图的示例
添加示例用于填充所需槽的意图
定义表单完成后机器人要采取的操作或响应
使用您定义的新意图和操作更新您的域
```

#### 回退和介入

- 超出的意图

为避免用户沮丧，您可以处理您知道用户可能会问的问题，但您尚未实现用户目标。

创建超出的意图

`nlu.yml`

```yaml
nlu:
- intent: out_of_scope
  examples: |
    - I want to order food
    - What is 2 + 2?
    - Who's the US President?
```

定义响应内容

`domain.yml`

```yaml
responses:
  utter_out_of_scope:
  - text: Sorry, I can't handle that request.
```

创建超出的规则

`rules.yml`

```yaml
rules:
- rule: out-of-scope
  steps:
  - intent: out_of_scope
  - action: utter_out_of_scope
```

- 单级NLU fallback

更新配置

`config.yml`

```yaml
pipeline:
# other components
- name: FallbackClassifier  # 使用分类器
  threshold: 0.7
```

定义响应信息

`domain.yml`

```yaml
responses:
  utter_please_rephrase:
  - text: I'm sorry, I didn't quite understand that. Could you rephrase?
```

创建规则

`rules.yml`

```yaml
rules:
- rule: Ask the user to rephrase whenever they send a message with low NLU confidence
  steps:
  - intent: nlu_fallback
  - action: utter_please_rephrase
```

- 处理低置信度

更新配置

`config.yml`

```yaml
policies:
- name: RulePolicy
  # Confidence threshold for the `core_fallback_action_name` to apply.
  # The action will apply if no other action was predicted with
  # a confidence >= core_fallback_threshold
  core_fallback_threshold: 0.4
  core_fallback_action_name: "action_default_fallback"
  enable_fallback_prediction: True
```

定义默认响应消息

`domain.yml`

```yaml
responses:
  utter_default:
  - text: Sorry I didn't get that. Can you rephrase?
```

自定义默认行为

`actions.py`

```python
from typing import Any, Text, Dict, List

from rasa_sdk import Action, Tracker
from rasa_sdk.events import UserUtteranceReverted
from rasa_sdk.executor import CollectingDispatcher

class ActionDefaultFallback(Action):
    """Executes the fallback action and goes back to the previous state
    of the dialogue"""

    def name(self) -> Text:
        return ACTION_DEFAULT_FALLBACK_NAME

    async def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:
        dispatcher.utter_message(template="my_custom_fallback_template")

        # Revert user message which led to fallback.
        return [UserUtteranceReverted()]
```

- 两级fallback

更新配置

`config.yml`

```yaml
pipeline:
# other components
- name: FallbackClassifier
  threshold: 0.7

policies:
# other policies
- RulePolicy
```

定义回退响应

`domain.yml`

```yaml
responses:
  utter_ask_rephrase:
  - text: I'm sorry, I didn't quite understand that. Could you rephrase?
```

定义两级回退规则

`rules.yml`

```yaml
rules:
- rule: Implementation of the Two-Stage-Fallback
  steps:
  - intent: nlu_fallback
  - action: action_two_stage_fallback
  - active_loop: action_two_stage_fallback
```

定义最终回退操作

`domain.yml`

```yaml
responses:
  utter_default:
  - text: I'm sorry, I can't help you.
```

自定义行为

`actions.py`

```python
from typing import Any, Dict, List, Text

from rasa_sdk import Action, Tracker
from rasa_sdk.events import UserUtteranceReverted
from rasa_sdk.executor import CollectingDispatcher

class ActionDefaultFallback(Action):
    def name(self) -> Text:
        return "action_default_fallback"

    def run(
        self,
        dispatcher: CollectingDispatcher,
        tracker: Tracker,
        domain: Dict[Text, Any],
    ) -> List[Dict[Text, Any]]:

        # tell the user they are being passed to a customer service agent
        dispatcher.utter_message(text="I am passing you to a human...")
        
        # assume there's a function to call customer service
        # pass the tracker so that the agent has a record of the conversation between the user
        # and the bot for context
        call_customer_service(tracker)
     
        # pause the tracker so that the bot stops responding to user input
        return [ConversationPaused(), UserUtteranceReverted()]
```

- 总结

对于范围外意图
```
将每个范围外意图的训练示例添加到您的 NLU 数据
定义范围外响应或操作
为每个范围外意图定义规则
添加 RulePolicy到 config.yml
```
对于单阶段 NLU 回退
```
在 config.yml 中将 FallbackClassifier 添加到您的管道
定义回退响应或操作
为 nlu_fallback 意图定义规则
将 RulePolicy 添加到 config.yml
```
用于处理低核心置信度：
```
配置config.yml 中核心回退的规则策略
可选择自定义您配置的回退操作
定义 utter_default 
```
响应对于两阶段回退
```
在 config.yml 中将 FallbackClassifier 添加到您的管道
为触发 action_two_stage_fallback 操作的 nlu_fallback 意图定义规则
在您的域中定义范围外意图
将 RulePolicy 添加到 config.yml
```
用于移交给人类
```
配置您的前端以切换主机
编写自定义操作（可能是您的后备操作）以发送移交有效负载
添加触发切换的规则（如果不是回退的一部分）
将 RulePolicy 添加到 config.yml
```

#### 处理意外输入

通用打断

```
为单轮交互定义规则
使用 ResponseSelector 进行常见问题解答和闲聊中断
```

上下文打断

```
将 requests_slot 设为分类槽（用于表单）
针对特定上下文对感叹词的响应编写stories，在适用的情况下使用槽值
```

#### 上下文对话

- 定义槽

`domain.yml`

```yaml
slots:
  likes_music:
    type: bool
```

- 创建stories

`stories.yml`

```yaml
stories:
  - story: User likes music
    steps:
    - intent: how_to_get_started
    - action: utter_get_started
    - intent: affirm
    - action: action_set_music_preference
    - slot_was_set:
      - likes_music: True
    - action: utter_awesome

  - story: User doesn't like music
    steps:
    - intent: how_to_get_started
    - action: utter_get_started
    - intent: deny
    - action: action_set_music_preference
    - slot_was_set:
      - likes_music: False
    - action: utter_goodbye
```



#### 接触用户



## 模块介绍

- nlu

用于理解用户消息，包括意图识别和实体识别，它会把用户的输入转换为结构化的数据。

配置意图以及触发该意图的文本

`nlu.md`

```markdown
## intent:greet
- 你好
- 上午好
- 下午好
- 早上好
- 晚上好

## intent:mood_happy
- 很好
- 我很好

## intent:mood_unhappy
- 我很难受
- 我心情很差
```

`nlu.yml`

```yaml
- intent: ask_name
  examples: |
    - what is your name
    - tell me your name
    - what others call you
    - what should I call you
```

配置文件`nlu_config.yml`

```yaml
language: zh
pipeline: tensorflow_embedding
```

- core

是一个对话管理平台，用于举行对话和决定下一步做什么。

> Stories

通过story这种类型作为训练数据来训练助手的对话管理模型。 此外story还可以可用于训练能够推广到看不见的对话路径的模型。

`stories.md`

```markdown
## story_happy

* greet
    - utter_greet
* mood_happy
    - utter_happy


## story_unhappy

* greet2
    - utter_greet
* mood_unhappy
    - utter_unhappy
```

`stories.yml`

```yaml
- story: happy name path
  steps:
  - intent: greet
  - action: utter_greet
  - intent: ask_name
  - action: utter_name
```

> Domain

domain定义了助手在其中运行的范围。 此外指定了机器人助手应该知道的意图，实体，位置，响应，形式和动作。 并且它还定义了对话会话的配置。

` domain.yml`

```
intents:
  - greet
  - mood_happy
  - mood_unhappy

actions:
- utter_greet
- utter_happy
- utter_unhappy

templates:
  utter_greet:
  - text: "你好，你今天过的怎么样"

  utter_happy:
  - text: "那很棒棒哦"

  utter_unhappy:
  - text: "咋了，可以告诉我吗"
```

