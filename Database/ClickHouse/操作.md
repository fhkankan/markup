# 对用户操作

# 数据库操作

```sql
# 查看所有数据库
show databases;
# 查看创建数据库的语句
show create database demo;
# 切换数据库
use xxx;
# 显示数据库版本
select version();
# 显示时间
select now();
# 查看当前使用得数据库
select database();

# 创建数据库
CREATE DATABASE [IF NOT EXISTS] db_name [ON CLUSTER cluster] [ENGINE = engine(...)]

create database tutorial;  # 默认使用Atomic引擎

# 删除数据库
drop database xxx;
```

# 数据表操作

## 创建

```sql
# 基本语法
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [db.]name
(
 name1 [type1] [DEFAULT | MATERIALIZED | ALIAS expr1],
 name2 [type2] [DEFAULT | MATERIALIZED | ALIAS expr2],
 ...
) ENGINE = engine

# 创建一个跟指定表完全一样的表，但是可以更换不同的引擎。
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [db.]name AS [db2.]name2 [ENGINE = engine]
 
# 建表并填充，表字段会自动根据 SELECT 的返回内容设置，并且，返回内容会作为新表内容填充进去。
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] [db.]name ENGINE = engine AS SELECT ...
```

MergeTree
```sql
create table if not exists test.tb_test(
    id Int64,
    datetime DateTime,
    content Nullable(String),
    value Nullable(Float64),
    date Date
)
engine = MergeTree                  # 使用mergeTree引擎，ch主要引擎
partition by toYYYYMM(datetime)     # 按照datetime这个字段的月进行分区
order by id                         # 按照id进行排序
TTL datetime + INTERVAL 3 DAY ;     # 三天过期
```
SummingMergeTree

```sql
CREATE TABLE IF NOT EXISTS tb_stat(
    regionId String,    # 门店id
    groupId String,     # 统计组id
    in int,             # 进客流
    out int,            # 出客流
    statDate DateTime   # 统计时间
)
ENGINE = SummingMergeTree
partition by (toYYYYMM(statDate), regionId)
ORDER BY (toStartOfHour(statDate), regionId, groupId);

insert into tb_stat values ('1232364', '111',  32, 2,  '2020-03-25 12:56:00');
insert into tb_stat values ('1232364', '111',  34, 44, '2020-03-25 12:21:00');
insert into tb_stat values ('1232364', '111',  54, 12, '2020-03-25 12:20:00');
insert into tb_stat values ('1232364', '222',  45, 11, '2020-03-25 12:13:00');
insert into tb_stat values ('1232364', '222',  32, 33, '2020-03-25 12:44:00');
insert into tb_stat values ('1232364', '222',  12, 23, '2020-03-25 12:22:00');
insert into tb_stat values ('1232364', '333',  54, 54, '2020-03-25 12:11:00');
insert into tb_stat values ('1232364', '333',  22, 74, '2020-03-25 12:55:00');
insert into tb_stat values ('1232364', '333',  12, 15, '2020-03-25 12:34:00');

select toStartOfHour(statDate), regionId, groupId, sum(in), sum(out)
from tb_stat group by toStartOfHour(statDate), regionId, groupId;
```

Merge

```sql
create t1 (id UInt16, name String) ENGINE=TinyLog;
create t2 (id UInt16, name String) ENGINE=TinyLog;
create t3 (id UInt16, name String) ENGINE=TinyLog;

insert into t1(id, name) values (1, 'first');
insert into t2(id, name) values (2, 'xxxx');
insert into t3(id, name) values (12, 'i am in t3');

create table t (id UInt16, name String) ENGINE=Merge(currentDatabase(), '^t');

select _table,* from t order by id desc;
```

Distributed

```sql
# 默认情况下，CREATE、DROP、ALTER、RENAME操作仅仅在当前执行该命令的server上生效。在集群环境下，可以使用ON CLUSTER语句，这样就可以在整个集群发挥作用。
# 创建分布式表
CREATE TABLE IF NOT EXISTS user_cluster ON CLUSTER cluster_3shards_1replicas
(
    id Int32,
    name String
)ENGINE = Distributed(cluster_3shards_1replicas, default, user_local,id);

# 参数
"""
cluster_name：集群名称，与集群配置中的自定义名称相对应。
database_name：数据库名称
table_name：表名称
sharding_key：可选的，用于分片的key值，在数据写入的过程中，分布式表会依据分片key的规则，将数据分布到各个节点的本地表。
"""

# 创建本地表
CREATE TABLE IF NOT EXISTS user_local (
    id Int32,
    name String
)
ENGINE = MergeTree()
ORDER BY id
PARTITION BY id
PRIMARY KEY id;

# 有两台服务器cdh04,cdh05组成集群
# 在cdh04对user_local插入数据
INSERT INTO user_local VALUES(1,'tom'),(2,'jack');
# 查询user_cluster，发现同步了数据，通过user_cluster表可以操作所有的user_local表
select * from user_cluster;  
# 向user_cluster中插入一些数据
INSERT INTO user_cluster VALUES(3,'lilei'),(4,'lihua');
select * from user_cluster;
# 查询cdh04的user_local，发现有一部分user_cluster
select * from user_local;
# 查询cdh05的user_local，发现有一部分user_cluster，与cdh04共同组成了user_cluster
select * from user_local;
```



## 修改

```
# 修改表中数据过期时间，到期后数据会在merge时被删除
ALTER TABLE test.tb_test
MODIFY TTL datetime + INTERVAL 1 DAY;

# 删除分区，可用于定时任务删除旧数据
alter table tb_test drop partition '202005';



--修改数据，不推荐使用
alter table tb_test update content = 'hello click' where id=52;

--删除数据，不推荐使用
alter table tb_test delete WHERE id=56;
```

## 分区

按时间分区

```
toYYYYMM(EventDate)：按月分区
toMonday(EventDate)：按周分区
toDate(EventDate)：按天分区
```

按指定列分区

```
PARTITION BY cloumn_name
```

对分区的操作

```sql
alter table test1 DROP PARTITION [partition]   #删除分区
alter table test1 DETACH PARTITION [partition]	#下线分区
alter table test1 ATTACH PARTITION [partition]	#恢复分区
alter table .test1 FREEZE PARTITION [partition]	#备份分区
```

# 数据操作

## 增

```sql
insert into tb_test values (5, '2020-02-29 12:38:37', 'abcde', 12.553, '2020-04-25');



```

## 删

## 改

## 查

```sql
select * from tb_test order by id;


```

# 数据同步

- 分区拷贝

```sql
# DETACH/FREEZE分区，进行SCP拷贝，然后再ATTACH
alter table db.table DETACH PARTITION [partition];  	# 下线分区
alter table db.table FREEZE PARTITION [partition];   	# 备份分区
alter table db.table ATTACH PARTITION [partition];  	# 上线分区
```

- 采用remote函数
```sql
insert into db.table select * from remote('目标IP',db.table,'user','passwd')
```
- csv文件导入clickhouse
```sql
cat test.csv | clickhouse-client -u user --password password --query="INSERT INTO db.table FORMAT CSV"
```
- 同步mysql库中表
```sql
CREATE TABLE tmp ENGINE = MergeTree ORDER BY id AS SELECT * FROM mysql('hostip:3306', 'db', 'table', 'user', 'passwd') ;
```
- clickhouse-copier 工具

