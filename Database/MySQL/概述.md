# 概述

## 引擎

数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL**的核心就是存储引擎**。

```sql
SHOW ENGINES  # 命令来查看MySQL提供的引擎

SHOW VARIABLES LIKE 'storage_engine'; # 查看数据库默认使用哪个引擎
```

### 类型

- InnoDB

InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，InnoDB是默认的MySQL引擎。InnoDB主要特性有：

1、**InnoDB给MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎**。

InnoDB锁定在行级并且也在SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合

2、InnoDB是为处理巨大数据量的最大性能设计。它的CPU效率可能是任何其他基于磁盘的关系型数据库引擎锁不能匹敌的

3、InnoDB存储引擎完全与MySQL服务器整合，InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上

4、**InnoDB支持外键完整性约束**

5、存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键

6、InnoDB被用在众多需要高性能的大型数据库站点上

InnoDB不创建目录，使用InnoDB时，MySQL将在MySQL数据目录下创建一个名为ibdata1的10MB大小的自动扩展数据文件，以及两个名为ib_logfile0和ib_logfile1的5MB大小的日志文件

- MyISAM

MyISAM基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但**不支持事物**。MyISAM主要特性有：

1、大文件（达到63位文件长度）在支持大文件的文件系统和操作系统上被支持

2、当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，以及若下一个块被删除，就扩展到下一块自动完成

3、每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16

4、最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上

5、BLOB和TEXT列可以被索引

6、NULL被允许在索引的列中，这个值占每个键的0~1个字节

7、所有数字键值以高字节优先被存储以允许一个更高的索引压缩

8、每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，**MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快**

9、可以把数据文件和索引文件放在不同目录

10、每个字符列可以有不同的字符集

11、有VARCHAR的表可以固定或动态记录长度

12、VARCHAR和CHAR列可以多达64KB

**使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）**

- MEMORY

MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。MEMORY主要特性有：

1、MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度

2、MEMORY存储引擎执行HASH和BTREE缩影

3、可以在一个MEMORY表中有非唯一键值

4、MEMORY表使用一个固定的记录长度格式

5、MEMORY不支持BLOB或TEXT列

6、MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引

7、MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）

8、MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享

9、当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行DELETE FROM或TRUNCATE TABLE，或者删除整个表（使用DROP TABLE）

### 使用

不同的存储引擎都有各自的特点，以适应不同的需求，如下所示：

如果要提供提交、回滚、崩溃恢复能力的事物安全（ACID兼容）能力，并要求实现并发控制，InnoDB是一个好的选择

如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较高的处理效率

如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果

如果只有INSERT和SELECT操作，可以选择Archive，Archive支持高并发的插入操作，但是本身不是事务安全的。Archive非常适合存储归档数据，如记录日志信息可以使用Archive

使用哪一种引擎需要灵活选择，**一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求**，使用合适的存储引擎，将会提高整个数据库的性能

## 字段

### 数据类型

主要包括以下五大类：

```
整数类型：BIT、BOOL、TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT
浮点数类型：FLOAT、DOUBLE、DECIMAL
字符串类型：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB
日期类型：Date、DateTime、TimeStamp、Time、Year
其他数据类型：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等
```
- 整型

| 数据类型     | 含义                                 |
| ------------ | ------------------------------------ |
| bit          | 1个字节 范围(-128,127)               |
| bool         | 1个字节，实际是tinyint(1)            |
| tinyint(m)   | 1个字节 范围(-128~127)               |
| smallint(m)  | 2个字节 范围(-32768~32767)           |
| mediumint(m) | 3个字节 范围(-8388608~8388607)       |
| int(m)       | 4个字节 范围(-2147483648~2147483647) |
| bigint(m)    | 8个字节 范围(+-9.22*10的18次方)      |

取值范围如果加了unsigned，则最大值翻倍，如tinyint unsigned的取值范围为(0~256)。

 int(m)里的m与你存放的数值型的数的大小无关。

m是为了告诉MYSQL数据库，这个字段的存储的数据的宽度为m位数, 当然如果你不是m位数（只要在该类型的存储范围之内）MYSQL也能正常存储。效果查看

```
# 将字段属性改为unsigned zerofill（无符号,用0来填充位数）
`uid` int(3) unsigned zerofill NOT NULL,
# 插入数据，发现系统会自动把uid字段M不够3位的在左侧用0来填充。
insert into `test` (`uid`) VALUES(11);
```

- 浮点型

| 数据类型    | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| float(m,d)  | 单精度浮点型  8位精度(4字节)   m总个数，d小数位，如果d<=24则为默认的FLOAT，否则则会自动被转换为DOUBLE型。 |
| double(m,d) | 双精度浮点型  16位精度(8字节)   m总个数，d小数位             |

设一个字段定义为float(6,3)，如果插入一个数123.45678,实际数据库里存的是123.457，但总个数还以实际为准，即6位。整数部分最大是3位，如果插入数12.123456，存储的是12.1234，如果插入12.12，存储的是12.1200.

- 定点数

| 数据类型     | 含义                                                  |
| ------------ | ----------------------------------------------------- |
| decimal(m,d) | m+1或m+2字节，参数m<65 是总个数，d<30且d<m 是小数位。 |

浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值。 

- 字符串

| 数据类型   | 含义                                  |
| ---------- | ------------------------------------- |
| char(n)    | n字符，最多255个字节                  |
| varchar(n) | n字符，n<=255，最多64K个字节          |
| tinytext   | 可变长度，最多255个字节，大小写不敏感 |
| text       | 可变长度，最多64K字节，大小写不敏感   |
| mediumtext | 可变长度，最多16M字节，大小写不敏感   |
| longtext   | 可变长度，最多4G字节，大小写不敏感    |

char/varchar：
```
char(n) 若存入字符数小于n，则以空格补于其后，查询之时再将空格去掉。所以char类型存储的字符串末尾不能有空格，varchar不限于此。 

char(n) 固定长度，char(4)不管是存入几个字符，都将占用4个字节，varchar是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，所以varchar(4),存入3个字符将占用4个字节。 

char类型的字符串检索速度要比varchar类型的快。
```
varchar/text： 
```
varchar可指定n，text不能指定，内部存储varchar是存入的实际字符数+1个字节（n<=255）或2个字节(n>255)，text是实际字符数+2个字节。 

text类型不能有默认值。 

varchar可直接创建索引，text创建索引要指定前多少个字符。varchar查询速度快于text,在都创建索引的情况下，text的索引似乎不起作用。
```

- 二进制

| MySQL数据类型 | 含义                                                |
| ------------- | --------------------------------------------------- |
| binary(m)     | m字节，类似Char的二进制存储，特点是插入定长不足补0  |
| varbinary(m)  | m字节，类似VarChar的变长二进制存储，特点是定长不补0 |
| tinyblob      | <255字节，大小写不敏感                              |
| blob          | <64K字节，大小写不敏感                              |
| mediumblob    | <16M字节，大小写不敏感                              |
| longblob      | <4G字节，大小写不敏感                               |

binary/char

```
BINARY和VARBINARY类类似于CHAR和VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。
```

blob/text

```
BLOB和text存储方式不同，TEXT以文本方式存储，英文存储区分大小写，而Blob是以二进制方式存储，不分大小写。

BLOB存储的数据只能整体读出。 

TEXT可以指定字符集，BLO不用指定字符集。
```

- 日期时间

| MySQL数据类型 | 含义                                        |
| ------------- | ------------------------------------------- |
| date          | 3字节，日期 '2008-12-2'                     |
| time          | 3字节，时间 '12:25:36'                      |
| datetime      | 8字节，日期时间 '2008-12-2 22:06:44'        |
| timestamp     | 4字节，自动存储记录修改时间，如'2009-07-19' |
| year          | 1字节，如'2019'                             |

若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。

 ### 类型属性

| MySQL关键字        | 含义                     |
| ------------------ | ------------------------ |
| NULL               | 数据列可包含NULL值       |
| NOT NULL           | 数据列不允许包含NULL值   |
| DEFAULT            | 默认值                   |
| PRIMARY KEY        | 主键                     |
| UNIQUE             | 唯一                     |
| AUTO_INCREMENT     | 自动递增，适用于整数类型 |
| UNSIGNED           | 无符号                   |
| CHARACTER SET name | 指定一个字符集           |

### 使用

- 选择数据类型基本原则

前提：使用适合存储引擎。

选择原则：根据选定的存储引擎，确定如何选择合适的数据类型。

下面的选择方法按存储引擎分类：

MyISAM 数据存储引擎和数据列：MyISAM数据表，最好使用固定长度(CHAR)的数据列代替可变长度(VARCHAR)的数据列。

MEMORY存储引擎和数据列：MEMORY数据表目前都使用固定长度的数据行存储，因此无论使用CHAR或VARCHAR列都没有关系。两者都是作为CHAR类型处理的。

InnoDB 存储引擎和数据列：建议使用 VARCHAR类型。

对于InnoDB数据表，内部的行存储格式没有区分固定长度和可变长度列（所有数据行都使用指向数据列值的头指针），因此在本质上，使用固定长度的CHAR列不一定比使用可变长度VARCHAR列简单。因而，主要的性能因素是数据行使用的存储总量。由于CHAR平均占用的空间多于VARCHAR，因 此使用VARCHAR来最小化需要处理的数据行的存储总量和磁盘I/O是比较好的。

## 事务

### 原理步骤

事务开启之后, 所有的操作都会临时保存到事务日志中, 事务日志只有在得到 commit 命令才会同步到数据表 中，其他任何情况都会清空事务日志(rollback，断开连接)

步骤

```
1) 客户端连接数据库服务器，创建连接时创建此用户临时日志文件
2) 开启事务以后，所有的操作都会先写入到临时日志文件中
3) 所有的查询操作从表中查询，但会经过日志文件加工后才返回
4) 如果事务提交则将日志文件中的数据写到表中，否则清空日志文件。
```

### 隔离级别

- 四大特性

| 事务特性               | 含义                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 原子性Atomicity  | 每个事务都是一个整体，不可再拆分，事务中所有的 **SQL** 语句要么都执行成功， 要么都失败。 |
| 一致性Consistency      | 事务在执行前数据库的状态与执行后数据库的状态保持一致。如:转账前 **2** 个人的 总金额是 **2000**，转账后 **2** 个人总金额也是 **2000** |
| 隔离性Isolation  | 事务与事务之间不应该相互影响，执行时保持隔离的状态。         |
| 持久性Durability | 一旦事务执行成功，对数据库的修改是持久的。就算关机，也是保存下来的。 |

- 隔离级别

事务在操作时的理想状态: 所有的事务之间保持隔离，互不影响。

因为并发操作，多个用户同时访问同一个 数据。可能引发并发访问的问题

| 并发访问问题 | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| 脏读         | 一个事务读取到了另一个事务中尚未提交的数据                   |
| 不可重复读   | 一个事务中两次读取的数据内容不一致，要求的是一个事务中多次读取时数据是一致的，这 是事务 **update** 时引发的问题 |
| 幻读         | 一个事务中两次读取的数据的数量不一致，要求在一个事务多次读取的数据的数量是一致 的，这是 **insert** 或 **delete** 时引发的问题 |

mysql数据库隔离级别：上面级别最低，下面级别最高

| 级别 | 名字     | 隔离级别           | 脏读 | 不可重复读 | 幻读 | 数据库默认隔离级别 |
| ---- | -------- | ------------------ | ---- | ---------- | ---- | ------------------ |
| 1    | 读未提交 | `read uncommitted` | 是   | 是         | 是   |                    |
| 2    | 读已提交 | `read committed`   | 否   | 是         | 是   | Oracle,SQL Server  |
| 3    | 可重复读 | `repeatable read`  | 否   | 否         | 是   | MySQL              |
| 4    | 串行化   | `serializable`     | 否   | 否         | 否   |                    |

隔离级别命令

```sql
# 查询全局事务隔离级别
select @@tx_isolation;

# 设置事务隔离级别
set global transaction isolation level serializable;
```

## 索引

### 实现原理

[索引实现](https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/6824277.html)

[索引详解](https://www.jb51.net/article/133626.htm)

MySQL中的索引的存储类型有两种：BTREE、HASH

> 索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引

MyISAM和InnoDB存储引擎：只支持BTREE索引， 也就是说默认使用BTREE，不能够更换

MEMORY/HEAP存储引擎：支持HASH和BTREE索引

### 索引类型

**单列索引**

​	普通索引：基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值

​	唯一索引：索引列中的值必须是唯一的，但是允许为空值

​	主键索引：是一种特殊的唯一索引，不允许有空值

**组合索引**

在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

> 注意索引失效
>
> 如果不是按照复合索引的最左列开始查找，则无法使用索引
>
> 如果查找时跳过了索引中的列，则只有前面的索引列会用到，后面的索引列会失效
>
> 如果查询中有某个列的范围查询（如like），则该列右边的所有列都无法使用索引优化查找。

**全文索引**

要求引擎MyISAM，在一堆文字中，通过其中的某个关键字等，就能找到该字段所属的记录行。只能在CHAR,VARCHAR,TEXT类型字段上使用全文索引。

**空间索引**

要求引擎MyISAM，空间索引是对空间数据类型的字段建立的索引。在创建空间索引时，使用SPATIAL关键字。创建空间索引的列，必须将其声明为NOT NULL。MySQL中的空间数据类型有四种，GEOMETRY、POINT、LINESTRING、POLYGON。

# SQL语法

- 每条语句以分号结尾。
- SQL 中不区分大小写，关键字中认为大写和小写是一样的

注释方法

```
--空格	// 单行注释
/**/	 // 多行注释
#		 // mysql特有注释
```

# Python交互

```python
# 安装pymysql
pip install pymsql
# 在__init__.py文件中导入
import pymsql
pymsql.install_as_MySQLdb()
```

