# ConfigMap

## 创建

### help

```shell
kubectl create  configmap --help  #可以使用cm替代configmap

Examples:
  # 从目录创建  文件名称为键  文件内容为值
  kubectl create configmap my-config --from-file=path/to/bar  

  # 从文件创建 key1为键 文件内容为值
  kubectl create configmap my-config --from-file=key1=/path/to/bar/file1.txt --from-file=key2=/path/to/bar/file2.txt 

  # 直接命令行给定,键为key1 值为config1
  kubectl create configmap my-config --from-literal=key1=config1 --from-literal=key2=config2   

  # 从文件创建 文件名为键 文件内容为值
  kubectl create configmap my-config --from-file=path/to/bar   

  # 从env文件创建
  kubectl create configmap my-config --from-env-file=path/to/bar.env

  Usage:
  kubectl create configmap NAME [--from-file=[key=]source] [--from-literal=key1=value1] [--dry-run=server|client|none]
[options]

Use "kubectl options" for a list of global command-line options (applies to all commands).
```

### 目录

目录内容
```yaml
# 创建configmap目录
# ls /opt/yaml/configmap

# 创建game.properties文件
enemies=aliens
lives=3
enemies.cheat=true
enemies.cheat.level=noGoodRotten
secret.code.passphrase=UUDDLRLRBABAS
secret.code.allowed=true
secret.code.lives=30

# ui.propertes文件
color.good=purple
color.bad=yellow
allow.textmode=true
how.nice.to.look=fairlyNice
```
命令
```python
# 创建configmap
kubectl create configmap game-config-test --from-file=/opt/yaml/configmap
# game-config-test ：configmap的名称
# --from-file：指定在目录下的所有文件都会被用在 ConfigMap 里面创建一个键值对，键的名字就是文件名，值就是文件的内容

# 查看configmap文件
kubectl get cm
# 查看详细信息 -o 指定输出格式为yaml
kubectl get cm game-config-test -o yaml
"""
apiVersion: v1
data:
  game.properties: |   # | 前是文件名； | 后是文件内容
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
  ui.propertes: |     # | 前是文件名； | 后是文件内容
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice
kind: ConfigMap      # 类型
metadata:
  creationTimestamp: "2021-06-04T06:45:42Z"
  name: game-config-test   # 名称
  namespace: default       # 命名空间
  resourceVersion: "625034"
  uid: 8a7f0064-f816-4e70-a367-bd37371dcaec
"""
# 描述configmap
kubectl describe cm game-config-test -n default
# 清空环境 
kubectl delete cm/game-config-test -n default
```

### 文件

指定为一个文件就可以从单个文件中创建ConfigMap

```shell
# --from-file这个参数可以使用多次，可以分别指定game.properties,ui.propertes，效果和指定整个目录是一样的
kubectl create configmap game-config-test2  --from-file=/opt/yaml/configmap/game.properties --from-file=/opt/yaml/configmap/ui.propertes 

# 查看
kubectl get cm -n default
kubectl describe cm game-config-test2 -n default
kubectl get cm game-config-test2 -o yaml
```

### 文字

```shell
# 使用--from-literal 方式直接创建configmap
kubectl create configmap test-config-1 --from-literal=key1=value1 --from-literal=key2=value2

# 查看
kubectl get cm -n default
kubectl describe cm/test-config-1 -n default
kubectl get cm test-config-1 -o yaml
```

### yaml

文件

```yaml
# 直接通过配置文件的方式创建
# vim configmap-test1.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: game-config
  namespace: default
data:
  game.properties: |
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice
```

命令

```shell
kubectl apply -f configmap-test1.yaml

# 查看
kubectl  get cm/configmap-test-one -n default
kubectl describe cm/configmap-test-one -n default
kubectl  get cm/configmap-test-one -n default -o yaml
```

## 应用

你可以使用四种方式来使用 ConfigMap 配置Pod 中的容器：

1. 容器命令和参数中
2. 容器的环境变量
3. 在只读卷里面添加一个文件，让应用来读取
4. 编写代码在 Pod 中运行，使用 Kubernetes API 来读取 ConfigMap

创建2个yaml

```yaml
# 创建第一个configMap,   special.how: very   键名：键值
# vim configmap-for-pod.yaml
---
apiVersion: v1
kind: ConfigMap
metadata: 
  name: special-config
  namespace: default
data:
  special.how: very
  special.type: charm

# 创建第二个configMap
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-config
  namespace: default
data:
  log_level: INFO
```

创建configmap

```shell
kubectl delete -f config-for-pod.yaml
kubectl apply -f config-for-pod.yaml
kubectl get cm -n default
```

### 替代

在pod中使用ConfigMap来替代环境变量

- valueFrom -> configMapKeyRef 通过valueFrom 导入
- envFrom -> configMapRef 通过envFrom 导入

`yaml`

```yaml
# vim configmap-instead-podenv.yaml
# 第一种方式： 在pod中使用configmap配置,使用ConfigMap来替代环境变量
apiVersion: v1
kind: Pod
metadata:
  name: configmap-instead-podenv
spec:
  containers:
    - name: cm-instead-podenv
      image: centos:7.9.2009
      imagePullPolicy: IfNotPresent
      command: 
      - "/bin/sh"
      -  "-c"
      - "env"   # 容器一但运行会执行命令/bin/sh -c env，会在控制台打印一下

      env: # 第一种导入方式：在env中导入
        - name: SPECIAL_LEVEL_KEY   # name是当前容器环境变量的key
          valueFrom:                # 通过valueFrom导入
            configMapKeyRef: 
              name: special-config  # name是要引入哪个configMap的name
              key: special.how      # key是要引入该configMap中的哪个key
        - name: SPECIAL_TYPE_KEY
          valueFrom: 
            configMapKeyRef: 
              name: special-config 
              key: special.type 
      envFrom: # 第二种导入方式，直接使用envFrom导入
        - configMapRef: 
            name: env-config 
  restartPolicy: Never
```

查看

```python
# 查看日志可以发现,环境变量注入到了容器中了，打印env就结束了
kubectl apply -f configmap-instead-podenv.yaml
kubectl get po 
kubectl logs pod/configmap-instead-podenv -n default

"""
SPECIAL_TYPE_KEY=charm   # 这里的env是导入的
SPECIAL_LEVEL_KEY=very   # 这里的env是导入的
log_level=INFO     # 这里的env是导入的
"""
```

### 设置

将 ConfigMap 用作命令行参数时，需要先把 ConfigMap 的数据保存在环境变量中，然后通过 `$(VAR_NAME)` 的方式引用环境变量.

`yaml`

```yaml
第二种方式：用ConfigMap设置命令行参数
# vim configmap-for-cmdargs.yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-for-cmdargs
spec:
  containers:
    - name: configmap-for-cmdargs
      image: centos:7.9.2009
      imagePullPolicy: IfNotPresent
      command: 
      - "/bin/sh"
      - "-c"
      - "echo $(SPECIAL_LEVEL_KEY) $(SPECIAL_TYPE_KEY)"    # 命令行中通过${}获取环境变量参数
      env:
        - name: SPECIAL_LEVEL_KEY  # name是当前容器环境变量的key
          valueFrom:  # 通过valueFrom引入
            configMapKeyRef: 
              name: special-config  # name是要引入哪个configMap的name
              key: special.how      # key是要引入该configMap中的哪个key
        - name: SPECIAL_TYPE_KEY 
          valueFrom: 
            configMapKeyRef: 
              name: special-config 
              key: special.type 
  restartPolicy: Never
```

查看

```python
kubectl apply -f configmap-for-cmdargs.yaml
kubectl get pods -n default
kubectl logs pod/configmap-for-cmdargs -n default

# 查看日志可以发现,环境变量注入到了容器中了，打印env就结束了
"""
very charm
"""
```

### 挂载

在数据卷里面使用这个ConfigMap,有不同的选项。最基本的就是将文件填入数据卷,在这个文件中,`键就是文件名,键值就是文件内容`，即在 Pod 中将 ConfigMap 当做文件使用。被挂载的 ConfigMap 内容会被自动更新-热更新。

`yaml`

```yaml
# 第三种方式：通过数据卷挂载ConfigMap
# vim configmap-pass-volume.yaml
apiVersion: v1
kind: Pod
metadata:
  name: configmap-pass-volume
spec:
  containers:
    - name: configmap-pass-volume
      image: centos:7.9.2009
      imagePullPolicy: IfNotPresent
      command: 
      - "/sbin/init"
      volumeMounts: # 挂载数据卷
        - name: configmap-volume # 指定数据卷名
          mountPath: /etc/config # 表示把conifg-volume数据卷挂载到容器的/etc/config目录下
  volumes:    # 定义数据卷
    - name: configmap-volume #给数据卷起名
      configMap:          #数据卷挂载configmap
        name: special-config #挂载的configmap名字
  restartPolicy: Never
```

命令

```python
kubectl apply -f configmap-pass-volume.yaml
get pods -n default
# 进入容器
kubectl exec -it pod/configmap-pass-volume -n default -- bash
# 查看挂载
ls /etc/config/
"""
special.how  special.type
"""
cd /etc/config/
cat special.how special.type
"""
verycharm
"""
```

