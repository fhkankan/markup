# 容器

容器是将多个数据存储到一起，每个数据称为该容器的元素。

## 数组

数组就是存储数据长度固定的容器，保证多个数据的数据类型要一致。

- 定义

声明

```java
dataType[] arrayRefVar;   // 首选的方法
dataType arrayRefVar[];  // 效果相同，但不是首选方法
```

创建

```java
arrayRefVar = new dataType[arraySize];

// 声明+创建
dataType[] arrayRefVar = new dataType[arraySize]; // 方式1
dataType[] arrayRefVar = new dataType[]{value0, value1, ..., valuek}; // 方式2
dataType[] arrayRefVar = {value0, value1, ..., valuek}; // 方式3
```

- 访问

每一个存储到数组的元素，都会自动的拥有一个编号，从0开始，这个自动编号称为数组索引 (index)，可以通过数组的索引访问到数组中的元素。

数组的元素是通过索引访问的。数组索引从 0 开始，所以索引值从 0 到 `arrayRefVar.length-1`

格式

```
数组名[索引]
```

属性

```
数组名.length
```

处理数组

```java
// 基本循环
double[] myList = {1.9, 2.9, 3.4, 3.5};
for (int i = 0; i < myList.length; i++) {
     System.out.println(myList[i] + " ");
}

// for...each
for (double element: myList) {
     System.out.println(element);
}
```

数组与函数

```java
// 作为函数的参数，传递的参数是数组内存的地址
public static void printArray(int[] array) {
  for (int i = 0; i < array.length; i++) {
    System.out.print(array[i] + " ");
  }
}
printArray(new int[]{3, 1, 2, 6, 4, 2});

// 作为函数的返回值，返回的数组的内存地址
public static int[] reverse(int[] list) {
  int[] result = new int[list.length];
 
  for (int i = 0, j = result.length - 1; i < list.length; i++, j--)       	{
    result[j] = list[i];
  }
  return result;
}
```

- 多维数组

多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组，

```
String str[][] = new String[3][4];
```

> 动态初始化

直接为每一维分配空间，格式如下：

```java
type[][] typeName = new type[typeLength1][typeLength2];
//type 可以为基本数据类型和复合数据类型，arraylength1 和 arraylength2 必须为正整数，arraylength1 为行数，arraylength2 为列数。

int a[][] = new int[2][3];
```

从最高维开始，分别为每一维分配空间

```java
String s[][] = new String[2][];
s[0] = new String[2];
s[1] = new String[3];
s[0][0] = new String("Good");
s[0][1] = new String("Luck");
s[1][0] = new String("to");
s[1][1] = new String("you");
s[1][2] = new String("!");
```

> 引用

对二维数组中的每个元素，引用方式为 `arrayName[index1][index2]`

```
num[1][0];
```

## 集合框架

集合框架被设计成要满足以下几个目标。

- 该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。
- 该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。
- 对一个集合的扩展和适应必须是简单的。

为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： **LinkedList**, **HashSet**, 和 **TreeSet** 等,除此之外你也可以通过这些接口实现自己的集合。

集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：

- **接口：**是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象
- **实现（类）：**是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。
- **算法：**是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。

集合按照其存储结构可以分为两大类，分别是单列集合`java.util.Collection`和双列集合`java.util.Map`。

![container](images/container.gif)

集合体系数据机构及效率

| 名称            | 存储结构    | 顺序          | 唯一性  | 查询效率       | 添加/删除效率 |
| --------------- | ----------- | ------------- | ------- | -------------- | ------------- |
| `ArrayList`     | 数组        | 有序(添加)    | 不唯一  | 索引查询效率高 | 低            |
| `LinkedList`    | 链表        | 有序(添加)    | 不唯一  | 低             | 最高          |
| `HashSet`       | 哈希表      | 无序          | 唯一    | 最高           | 最高          |
| `HashMap`       | 哈希表      | key无序       | key唯一 | 最高           | 最高          |
| `LinkedHashSet` | 哈希表+链表 | 有序(添加)    | 唯一    | 最高           | 最高          |
| `LinkedHashMap` | 哈希表+链表 | key有序(添加) | key唯一 | 最高           | 最高          |
| `treeSet`       | 二叉树      | 有序(升序)    | 唯一    | 中等           | 中等          |
| `treeMap`       | 二叉树      | 有序(升序)    | key唯一 | 中等           | 中等          |

## 迭代器

在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是Java集合中的一员，但它与`Collection`、`Map`接口有所不同，`Collection`接口与`Map`接口主要用于存储元素，而`Iterator`主要用于迭代访问（即遍历）`Collection`中的元素，因此`Iterator`对象也被称为迭代器。

**迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。

- 原理

Iterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。

- 遍历

想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作。需要使用Collection中的`iterator()`方法。

```java
public Iterator iterator()  // 获取集合对应的迭代器，用来遍历集合中的元素的。
```

* 方法
```java
public E next()  // 返回迭代的下一个元素。
public boolean hasNext()  // 如果仍有元素可以迭代，则返回 true。
public void remove()  // 从迭代器指向的collection中移除迭代器返回的最后一个元素（可选操作）
```

- 增强for循环

增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。

格式：

~~~java
for(元素的数据类型  变量 : Collection集合or数组){ 
  	//写操作代码
}
~~~

- 使用步骤

```
1.使用集合中的方法iterator()获取迭代器的实现类对象，使用Iterator接口接收(多态)
2.使用Iterator接口中的方法hasNext判断还有没有下一个元素
3.使用Iterator接口中的方法next取出集合中的下一个元素
```

示例

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestCollection2 {
    public static void main(String[] args) {
        Collection col1 = new ArrayList<>(); // 多台，接口去new实现类，向上类型转换
        col1.add("java"); // 向上类型转换，相当于Object o = new String("java")
        col1.add("html");
        col1.add("sql");
        // 加强for循环
        System.out.println("使用加强for循环");
        for (Object o : col1) {
            System.out.println(o + "\t");
        }
        // iterator
        System.out.println("使用iterator");
        // 多态 接口   实现类对象
        Iterator it = col1.iterator();
        while (it.hasNext()) {
            Object o = it.next();
            System.out.println(o + "\t");
        }
        // 另外写法
        System.out.println("for循环中使用iterator");
        for (Iterator it1 = col1.iterator(); it1.hasNext();) {
            System.out.println(it1.next() + "\t");
        }
        System.out.println("\n");
    }
}
```

## 泛型

### 基本使用

在向集合中添加元素是，元素类型进行了向上转型，任何类型都转换成了`Object`类型并添加到了集合中，而在遍历集合中元素时，使用了向下转型，转换成了`String`类型，所以这时出现了类型转换异常`java.lang.ClassCastException`

```java
import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List list1 = new ArrayList();
        list1.add(123); // 相当于Object o = new Integer(123)
        list1.add("java"); // 相当于Object o = new String("java")
        list1.add(new Person("jack")); // 相当于Object o = new Person("jack")

        // 遍历输出，运行时才报错
        for (Object o : list1) {
            String s = (String) o; // 向下类型转换
            System.out.println(s);
        }
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }
}
```

在JDK1.5时加入了泛型，在创建集合对象时规定集合中所存储的元素的数据类型。

泛型好处：将运行时期的ClassCastException，转移到了编译时期变成了编译失败；避免了类型强转的麻烦。

```java
import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<String> list1 = new ArrayList<String>();
        // 编译时报错，类型不对 
        list1.add(123); // 相当于Object o = new Integer(123)
        list1.add("java"); // 相当于Object o = new String("java")
        //  编译时报错，类型不对 
        list1.add(new Person("jack")); // 相当于Object o = new Person("jack")

        // 遍历输出
        for (Object o : list1) {
            String s = (String) o; // 向下类型转换
            System.out.println(s);
        }
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }
}
```

泛型只在编译期间起到作用，对加入到集合中的元素进行类型验证。通过反编译工具可以看到在编写代码时使用的泛型，经过编译之后与没有使用泛型的结果完全相同。

### 自定义

> 泛型类

定义泛型格式

```java
修饰符 class 类名<代表泛型的变量>{ }
```

示例

```java
public class MyGenericClass<MVP> {
	//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型
	private MVP mvp;
     
    public void setMVP(MVP mvp) {
        this.mvp = mvp;
    }
     
    public MVP getMVP() {
        return mvp;
    }
}
```

使用：在创建对象的时候确定泛型

```java
public class GenericClassDemo {
  	public static void main(String[] args) {		 
         // 创建一个泛型为String的类
         MyGenericClass<String> my = new MyGenericClass<String>();    	
         // 调用setMVP
         my.setMVP("大胡子登登");
         // 调用getMVP
         String mvp = my.getMVP();
         System.out.println(mvp);
         //创建一个泛型为Integer的类
         MyGenericClass<Integer> my2 = new MyGenericClass<Integer>(); 
         my2.setMVP(123);   	  
         Integer mvp2 = my2.getMVP();
    }
}
```

> 含有泛型的方法

定义格式

```java
修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }
```

示例

```java
public class MyGenericMethod {	  
    public <MVP> void show(MVP mvp) {
    	System.out.println(mvp.getClass());
    }
    
    public static <MVP> MVP show2(MVP mvp) {	
    	return mvp;
    }
}
```

使用：在调用方法时，确定泛型的类型

```java
public class GenericMethodDemo {
    public static void main(String[] args) {
        // 创建对象
        MyGenericMethod mm = new MyGenericMethod();
        // 演示看方法提示
        mm.show("aaa");
        mm.show(123);
        mm.show(12.45);
        // 静态方法
        mm.show2("bbb"); // 不建议
        MyGenericMethod.show2("bbb")
    }
}
```

> 含有泛型的接口

定义格式

```java
修饰符 interface接口名<代表泛型的变量> {  }
```

示例

```java
public interface MyGenericInterface<E>{
	public abstract void add(E e);
	
	public abstract E getE();  
}
```

使用格式1：定义类时确定泛型的类型

```java
public class MyImp1 implements MyGenericInterface<String> {
	@Override
    public void add(String e) {
        // 省略...
    }

	@Override
	public String getE() {
		return null;
	}
}
```

使用格式2：不确定泛型的类型，直到创建对象时，确定泛型的类型

```java
// 定义类时不确定
public class MyImp2<E> implements MyGenericInterface<E> {
	@Override
	public void add(E e) {
       	 // 省略...
	}

	@Override
	public E getE() {
		return null;
	}
}

// 创建对象时确定
public class GenericInterface {
    public static void main(String[] args) {
        MyImp2<String>  my = new MyImp2<String>();  
        my.add("aa");
    }
}
```

### 通配符

当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符`<?>`表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。

- 基本使用

泛型的通配符:不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。

此时只能接受数据,不能往该集合中存储数据。

```java
public static void main(String[] args) {
    Collection<Intger> list1 = new ArrayList<Integer>();
    getElement(list1);
    Collection<String> list2 = new ArrayList<String>();
    getElement(list2);
    // 泛型不存在继承关系 
    // Collection<Object> list = new ArrayList<String>();这种是错误的。
}
public static void getElement(Collection<?> coll){}
//？代表可以接收任意类型
```

- 高级使用

之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的**上限**和**下限**。

```java
// 泛型的上限

// 格式： 类型名称 <? extends 类 > 对象名称
// 意义： 只能接收该类型及其子类

// 泛型的下限

// 格式： 类型名称 <? super 类 > 对象名称
// 意义： 只能接收该类型及其父类型
```

现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类

```java
public static void main(String[] args) {
    Collection<Integer> list1 = new ArrayList<Integer>();
    Collection<String> list2 = new ArrayList<String>();
    Collection<Number> list3 = new ArrayList<Number>();
    Collection<Object> list4 = new ArrayList<Object>();
    
    getElement(list1);
    getElement(list2);//报错
    getElement(list3);
    getElement(list4);//报错
  
    getElement2(list1);//报错
    getElement2(list2);//报错
    getElement2(list3);
    getElement2(list4);
  
}
// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类
public static void getElement1(Collection<? extends Number> coll){}
// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类
public static void getElement2(Collection<? super Number> coll){}
```

## Collection接口

单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是`java.util.List`和`java.util.Set`。其中，`List`的特点是元素有序、元素可重复。`Set`的特点是元素无序，而且不可重复。`List`接口的主要实现类有`java.util.ArrayList`和`java.util.LinkedList`，`Set`接口的主要实现类有`java.util.HashSet`和`java.util.TreeSet`。

collection接口位于`java.util`中，它所存储的元素的特点 是不唯一(`List`接口)和无序(`Set`接口)的。

- 定义

```java
public interface Collection<E> extends Iterable<E>
```

collection接口继承了Iterable接口，说明集合框架具有一种能力，即可以使用加强for循环便利集合中元素对象的能力。

- 常用方法

```java
public boolean add(E e)  //  把给定的对象添加到当前集合中 。
public void clear()  // 清空集合中所有的元素。
public boolean remove(E e)  //  把给定的对象在当前集合中删除。
public boolean contains(E e)  //  判断当前集合中是否包含给定的对象。
public boolean isEmpty()  //  判断当前集合是否为空。
public int size()  //  返回集合中元素的个数。
public Object[] toArray()  //  把集合中的元素，存储到数组中。
```

实现

```java
import java.util.ArrayList;
import java.util.Collection;


public class TestCollection {
    public static void main(String[] args) {
        Collection col1 = new ArrayList();// 多态，接口去new实现类，向上类型转换
        // add
        System.out.println("添加元素之前，集合是否为空：" + col1.isEmpty());
        col1.add(123); // jdk1.5之后自动装箱，相当于Object o = new Integer(123)
        col1.add("helloworld"); // 相当于Object o = new String("helloworld")
        // isEmpty
        System.out.println("添加元素之后，集合是否为空：" +  col1.isEmpty());
        System.out.println("集合中元素的个数是：" + col1.size());
        // addAll
        Collection col2 = new ArrayList();
        col2.add("java");
        col2.add("html");
        col2.add("sql");
        col1.addAll(col2);
        System.out.println("集合中元素为：" + col1.toString());
        // contains,containsAll
        System.out.println("java在col1集合中是否存在："+col1.contains("java"));
        System.out.println("col1中是否包含col2中的全部元素："+ col1.containsAll(col2));
        // equlas
        System.out.println("col1是否合col2相等："  + col1.equals(col2));
        // remove，存在则返回true，否则为false
        System.out.println("删除java：" + col1.remove("java"));
        // clear
        System.out.println("删除所有：");
        col1.clear();
        // 删除col1和col2中相交的元素
        col1.removeAll(col2);
        System.out.println("coll.removeAll(col2) col1:" + col1);
        System.out.println("coll.removeAll(col2) col2:" + col2);
        // 删除将col1和col2中不相交的元素
        col1.retainAll(col2);
        System.out.println("coll.retainAll(col2) col1:" + col1);
        System.out.println("coll.retainAll(col2) col2:" + col2); 
    }
}
```

## List接口

### 概述

List接口位于`java.util`包中，是`Collection`接口的子接口，用于存储一组有序的不唯一的元素对象，有序指的是元素的添加顺序。

- 常用方法

```java
public void add(int index, E element) 
// 将指定的元素，添加到该集合中的指定位置上
    
public boolean addAll(int index, Collection<?extends E>c)
// 在指定位置上添加一批元素
    
public E remove(int index) 
// 移除列表中指定位置的元素, 返回的是被移除的元素
    
public E set(int index, E element) 
// 用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
    
public List<E> subList(int fromIndex, int. toIndex)
// 截取子集合，含头不含尾
    
public E get(int index) 
// 返回集合中指定位置的元素
 
public List<E> listIterator()
// 返回此列表元素列表迭代器
```

实现

```java
import java.util.ArrayList;
import java.util.List;

public class TestList {
    public static void main(String[] args) {
        List list1 = new ArrayList<>();
        // add
        list1.add("java");
        list1.add("html");
        System.out.println(list1);
        list1.add(0, "sql");
        System.out.println(list1);
        // addAll
        List list2 = new ArrayList<>();
        list2.add("haha");
        list2.add("hello");
        list1.addAll(list1);
        System.out.println(list1);
        // remove， 返回被删除的元素
        System.out.println("remove(2)" + list1.remove(2));
        System.out.println(list1);
        // get
        System.out.println(list1.get(1));
        System.out.println(list1);
        // set, 返回被替换的元素
        System.out.println("set('hehe')" + list1.set(2, "hehe"));
        System.out.println(list1);
        // subList
        List list3 = list1.subList(1, 3);
        System.out.println(list3);

    }
}
```

### 实现类

`List`接口的常用实现类有`ArrayList, LinkedList,Vector`

**ArrayList**

`ArrayList`类位于`java.util`包中，继承`AbstractList`类实现的`List`接口，底层采用的数据结构是数组，允许添加重复的元素，并且添加的元素是有序的，按照添加顺序进行存储。优点是遍历元素和随机访问元素的效率比较高，而由于底层数据结构是数组，所以添加 、删除元素的效率比较低，因为插入元素和删除元素需要前后移动元素的位置。该类从JDK1.2开始，是线程不同步的，在多线程同时访问时，可以提高访问的效率，但同时会降低访问的安全性。

**Vector**

`Vector`类也位于`java.util`包中，也是继承`AbstractList`类实现的`List`接口，底层采用的数据结构是数组。该类从JDK1.0开始，是线程同步的，在多线程同时访问时，会降低访问的效率，但同时会提高访问的安全性。

`ArrayList,Vector`两者在添加删除遍历元素的方式均相同，但是需要运行效率较高时使用`ArrayList`，需要安全性较高时使用`Vector`

**LinkedList**

`LinkedList`类位于`java.util`包中，继承`AbstractSequentialList`类，实现`List`接口与`Dque`接口，存储的元素可重复而且是按添加顺序进行存储，底层的数据结构采用的是链表，优点是插入和删除元素的效率比较高。

在`list`基础上扩展的方法

```java
public void addFirst(E e) 
//将指定元素插入此列表的开头。 
public void addLast(E e) 
//将指定元素添加到此列表的结尾。 

public E getFirst() 
//返回此列表的第一个元素。
public E getLast() 
//返回此列表的最后一个元素。

public E removeFirst() 
//移除并返回此列表的第一个元素。 
public E removeLast() 
//移除并返回此列表的最后一个元素。 

public E pop() 
//从此列表所表示的堆栈处弹出一个元素。相当于removeFirst()

public void push(E e) 
//将元素推入此列表所表示的堆栈。 

public boolean isEmpty() 
//如果列表不包含元素，则返回true。
```

实现

```java
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Vector;
import java.util.List;


public class LinkedListDemo {
    public static void main(String[] args) {
		LinkedList<String> link = new LinkedList<String>(); 
        //添加元素
		link.addFirst("abc1");
		link.addFirst("abc2");
		link.addFirst("abc3"); 
        System.out.println(link);

        // 获取元素 
        System.out.println(link.getFirst()); 					System.out.println(link.getLast());

        // 删除元素 
        System.out.println(link.removeFirst()); 		
        System.out.println(link.removeLast());

        while (!link.isEmpty()) { //判断集合是否为空 
            System.out.println(link.pop()); //弹出集合中的栈顶元素
		}
        
        System.out.println(link);
   }
}
```

## Set接口

`Set`接口也位于`java.util`包中，是`Collection`接口的子接口，存储一组无序且唯一的元素对象。`Set`接口并没有对`Collection`接口中的方法进行扩展，所以`Collection`接口中的方法`Set`接口都能使用。

`Set`集合有多个子类，如`java.util.HashSet, java.util.LinkedHashSet`

### HashSet

`HashSet`直接继承了`AbstractSet`类，实现了`Set`接口，所以`Set`接口中的方法被`HashSet`类所实现。

`HashSet `是根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。保证元素唯一性 的方式依赖于: `hashCode` 与 `equals`方法。

`HashSet`类的定义

```java
public class HashSet<E> 
extends AbstractSet<E>
implements Set<E>, Cloneable, java.io.Serializable
```

- 常规使用

`Collection`接口是集合框架顶层接口，`Collection`接口中的方法`HashSet`可以直接使用。

```java
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();
        // add
        set.add("java");
        set.add("html");
        set.add("sql");
        set.add("java")
        System.out.println(set.size());
        // remove
        set.remove("java");
        System.out.println(set.isEmpty());
        System.out.println(set.size());
        // for
        for (String string : set) {
            System.out.print(string + "\t");
        }
        // iterator
        System.out.println("\n\niterator方法");
        Iterator<String> it = set.iterator();
        while (it.hasNext()) {
            System.out.println(it.next() + "\t");
        }
    }
}
```

`HashSet`结合存储的数据是无序且唯一，原因是底层数据结构采用的是`Hashtable`。这种数据结构决定了`HashSet`的优点是查询、添加和删除速度快，缺点是无序。

- 存储结构

在JDK1.8之前，哈希表底层采用数组+链表实现，即使用链表处理冲突，同一hash值的链表都存储在一个链表里。 但是当位于一个桶中的元素较多，即hash值相等的元素较多时，通过key值依次查找的效率较低。

而JDK1.8中，哈 希表存储采用数组+链表+红黑树实现，当链表长度超过阈值(8)时，将链表转换为红黑树，这样大大减少了查找 时间。

简单的来说，哈希表是由数组+链表+红黑树(JDK1.8增加了红黑树部分)实现的。

对于我们来讲保证HashSet集合元素的唯一， 其实就是根据对象的hashCode和equals方法来决定的。如果我们往集合中存放自定义的对象，那么保证其唯一， 就必须复写hashCode和equals方法建立属于当前对象的比较方式。

- 自定义类型元素存储

给HashSet中存放自定义类型元素时，需要重写对象中的hashCode和equals方法，建立自己的比较方式，才能保证HashSet集合中的对象唯一。

```java
// 创建自定义类
package com.eachplus;

import java.util.Objects;

public class Student {
    private String name;
    private int age;

    public Student() {}

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }


    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Student student = (Student) o;
        return age == student.age && name.equals(student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

// 测试类
import java.util.HashSet;

public class HashSetDemo {
    public static void main(String[] args) {
        // 创建集合对象，该对象中存储Student类型对象
        HashSet<Student>  stuSet = new HashSet<Student>();
        // 存储
        Student stu = new Student("张三", 12);
        stuSet.add(stu);
        stuSet.add(new Student("李四", 10));
        stuSet.add(new Student("张三", 12));
        stuSet.add(stu);
        for (Student stu2:stuSet) {
            System.out.println(stu2);
        }
    }
}

```

### LinkedHashSet

`LinkedHashSet`的底层数据结构是哈希表和链表，使用哈希表存储结构，同时使用链表维护添加次序，所以`LinkedHashSet`又被称为有序的`HashSet`。

```java
// 自定义类
public class Person {
    // 私有属性
    private String name;
    private int age;

    // 构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    // 不重写hashCode和equals方法时，在HashSet中同样的类对象会被认为不同的地址
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + age;
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        Person other = (Person) obj;
        if (age != other.age) {
            return false;
        }
        if (name == null) {
            if (other.name != null) {
                return false;
            }
        } else if (!name.equals(other.name)) {
            return false;
        }
        return true;
    }

}


// 测试类 
import java.util.HashSet;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        Set<Person> set = new HashSet<Person>();
        // 创建Person类型的对象
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 12);
        // add
        set.add(p1);
        set.add(p2);
        set.add(p3);
        // Person不重写hashCode和equals方法时,为3个对象
        // 重写hashCode和equals后，为2个对象
        System.out.println(set.size());
        System.out.println(set);

    }
}
```

### TreeSet

`TreeeSet`的底层数据结构时红黑树，起优点是 按照升序排序，查询的速度比`List`快，因为`TreeSet`是按照内容去查询的。其缺点是查询速度没有`HashSet`快。

`TreeeSet`是`Map`接口的常用实现类，底层数据结构是红黑树，是有序的`set`集合，`TreeeSet`中要求具备比较规则。如果使用自定义的类时，要求自定的类实现`Comparable`接口，如果自定义的类没有实现`Comparable`接口，可以编写一个类实现`Comparator`接口，调用`TreeSet`的带参构造方法创建`TreeSet`对象。

构造方法

| 构造方法                                   | 描述                                                       |
| ------------------------------------------ | ---------------------------------------------------------- |
| `TreeSet()`                                | 创建一个empty的`TreeSet`对象，根据其元素的自然顺序进行排序 |
| `TreeSet(Comparator<?super E> comparator)` | 创建一个empty的`TreeeSet`对象，按照指定的比较器进行排序    |

基础操作

```java
import java.util.Iterator;
import java.util.TreeSet;

public class Test {
    public static void main(String[] args) {
        TreeSet<String> ts = new TreeSet<String>();
        // add, 按照a-z排序，而不是添加顺序
        ts.add("apple");
        ts.add("orange");
        ts.add("banana");
        System.out.println(ts.size());
        // for
        for (String str : ts) {
            System.out.println(str + "\t");
        }
        for (Iterator<String> ite = ts.iterator(); ite.hasNext();) {
            System.out.println(ite.next());
        }
        // contains
        System.out.println(ts.contains("hello"));
        // remove
        System.out.println(ts.remove("range"));
        System.out.println(ts);
        // isEmpty
        ts.clear();
        System.out.println(ts.isEmpty());
    }
}
```

自定义对象

```java
import java.util.TreeSet;

public class Test {
    public static void main(String[] args) {
        TreeSet<Person> ts = new TreeSet<Person>();
        // 创建Person类型的对象
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        ts.add(p1);
        ts.add(p2);
        ts.add(p3);
        // 由于Person类中没有Comparable接口，不具备比较大小的能力，添加报错
        System.out.println(ts.size());
        System.out.println(ts);

    }
}

public class Person {
    // 私有属性
    private String name;
    private int age;

    // 构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }
}

/*方法一：Test类不变，Person中实现Comparable接口*/
public class Person implements Comparable<Person> {
    // 私有属性
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // 构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    // 添加compareTo方法
    @Override
    public int compareTo(Person o) {
        if (this.getAge() < o.getAge()) {
            return -1; // 比较大小
        } else if (this.getAge() > o.getAge()) {
            return 1;
        } else {
            return this.getName().compareTo(o.getName());
        }
    }

}

/*方法二：Person类不变，Test类中变化*/
import java.util.Comparator;
import java.util.TreeSet;

public class Test {
    public static void main(String[] args) {
        TreeSet<Person> ts = new TreeSet<Person>(
            // 创建匿名内部类
            new Comparator<Person>(){
                @Override
                // 按照字母的长度进行排序
                public int compare(Person o1, Person o2){
                    return o1.getName().length() - o2.getName().length();
                }
            }
        );
        // 创建Person类型的对象
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        ts.add(p1);
        ts.add(p2);
        ts.add(p3);
        System.out.println(ts.size());
        System.out.println(ts);

    }
}
/*方法三：Person类不变，添加新的类LengthCom，Test类中变化*/
import java.util.Comparator;
import java.util.TreeSet;

public class Test {
    public static void main(String[] args) {
        // 创建比较规则对象
        Comparator<Person> com = new LengthCom();
        TreeSet<Person> ts = new TreeSet<Person>(com);
        // 创建Person类型的对象
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        ts.add(p1);
        ts.add(p2);
        ts.add(p3);
        System.out.println(ts.size());
        System.out.println(ts);

    }
}

import java.util.Comparator;

public class LengthCom implements Comparator<Person>{
    @Override
    // 按照字母的长度进行排序
    public int compare(Person o1, Person o2){
        return o1.getName().length() - o2.getName().length();
    }
    
}
```

## Map接口

`Map`接口也位于`java.util`包中，与`Collection`接口中不同的是，`Map`接口中存储的是`Key,value`映射的一组对象，其中，`key`是无序且唯一的，`value`是无序不唯一的。

与`collection`不同

```
1. Collection中的集合，元素是孤立存在的，向集合中存储元素采用一个个元素的方式存储。 Map中的集合，元素是成对存在的。每个元素由键与值两部分组成，通过键可以找对所对应的值。
2. Collection 中的集合称为单列集合， Map中的集合称为双列集合。
```

- 常用子类

`HashMap`：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的`hashCode(),equals()`方法。 

`LinkedHashMap`：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致，通过哈希表结构可以保证的键的唯一、不重复，需要重写键的`hashCode(),equals()`方法。

- 常用方法

```java
public V put(K key, V value) 
// 把指定的键与指定的值添加到Map集合中。key不重复，返回null；key重复，用新的value替换map中对应的value，返回被替换值
    
public V remove(Object key)
// 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值； 若是key不存在，返回null
    
public void clear()
// 清除集合中全部元素对象
    
public boolean isEEmpty()
// 判断集合对象是否为empty，如果为empty返回true

public boolean containsKey(Object key)
// 判断指定的key是否存在
     
public boolean containsValue(Object value)
// 判断指定的value是否存在
    
public V get(Object key)
// 根据指定的键，在Map集合中获取对应的值；若key不存在，返回null

public Set<K> keySet() 
// 获取Map集合中所有的键，存储到Set集合中。
    
public Collection<V> values()
// 获取Map集合中所有的value，存储到Collection集合中

public Set<Map.Entry<K,V>> entrySet() 
// 获取到Map集合中所有的键值对对象的集合(Set集合)。
```

### HashMap

`HashMap`是`Map`接口的常用实现类，底层数据结构采用的是`Hashtable`。`HashMap`中的key是无序的，value与key映射，所以value与key一起无序。但`HashMap`中的key是`Hashtable`，所以`HashMap`的特点是添加删除及查询元素的速度都快，缺点是无序。

在使用自定义类作为key时，要求重写`hashCode(),equals(Object obj)`方法去掉重复元素来保证key的唯一性。

- 基本操作

```java
// 自定义类
public class Person {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public Person() {
    }
    
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }
    
    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age && name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }

}

// 测试类
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        // 创建HashMap集合对象，key为String，value为Person
        HashMap<String, Person> hm = new HashMap<String, Person>();
        // 创建Person类型的对象,因为Person在这里做value，无需重写hashCode()和equals()方法
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        hm.put(p1.getName(), p1);
        hm.put(p2.getName(), p2);
        hm.put(p3.getName(), p3); // p1被覆盖
        System.out.println(hm.size());
        System.out.println(hm);
        // judge
        System.out.println(hm.containsKey("lucy"));
        System.out.println(hm.containsValue(p1));
        
        // 遍历
        // 获取所有key
        Set<String> setStr = hm.keySet(); // 获取所有key
        for (String str : setStr) {
            System.out.println("key:->" + str);
            System.out.println("value->"+ hm.get(str));
        }
        for (Iterator<String> ite = setStr.iterator(); ite.hasNext();) {
            String key = ite.next();  // 获取key
            System.out.print("key->" + key);   // 获取value
            Person p = hm.get(key);
            System.out.println("value->" + p.getName() + "\t" + p.getAge());
        }
        Iterator<String> ite = setStr.iterator();
        while(ite.hasNext()){
            String key = ite.next();
            System.out.print("key->" + key);
            Person p = hm.get(key);
            System.out.println("value->" + p.getName() + "\t" + p.getAge());
        }
        // 获取所有value
        Collection<Person> colValues = hm.values();
        for (Person p : colValues) {
            System.out.println("value->" + p.getName() + "\t" + p.getAge());
        }
        // 获取所有key-value
        Set<Map.Entry<String, Person>> setMap = hm.entrySet();
        for (Map.Entry<String, Person> pEntry: setMap){
            String key = pEntry.getKey();
            Person p = pEntry.getValue();
            System.out.println("key->" + key + "\n" + "value->" + p.getName() + p.getAge());
        }
        
        // 这里以Person做key，必须重写hashCode()和equals()方法
        HashMap<Person, String> hp = new HashMap<>();
        hp.put(new Person("张三", 19), "河南");
        hp.put(new Person("李四", 20), "山西");
        hp.put(new Person("张三", 19), "山东");  // 覆盖
        Set<Map.Entry<Person, String>> setMap = hp.entrySet();
        for (Map.Entry<Person, String> entry : setMap) {
            Person key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + "--->" + value);
        }
    }
}
```

### LinkedHashMap

`LinkedHashMap`集合底层是哈希表+链表，链表维护添加顺序。 是一个有序集合，存储元素和取出元素的顺序是一致的

`LinkedHashMap`的使用方法和`HashMap`相同。

类定义

```java
public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>{}
```

使用

```java
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.Map;

public class Test {
    public static void main(String[] args) {
        LinkedHashMap<String, String> map = new LinkedHashMap<>();
        map.put("张三", "19");
        map.put("李四", "18");
        map.put("张三", "18");
        System.out.println(map);
        Set<Map.Entry<String, String>> entrySet = map.entrySet();
        for (Map.Entry<String, String> entry : entrySet) {
            System.out.println(entry.getKey() + "--->" + entry.getValue());
        }
    }
}
```

### HashTable

`HashTable`底层也是一个哈希表，是一个线程安全的集合，是单线程集合，速度慢。已经被`HashMap`替代。

`Hashtable`继承`Dictionary`类实现Map接口，`HashMap`继承`AbstractMap`类实现Map接口，直接父类不同。

`Hashtable`重安全，是线程同步的，相对效率就降低，而`HashMap`是线程不同步的，提高了效率，相对安全性就降低，需程序猿自己实现多线程的安全问题。

`Hashtable`不允许使用null的key与value，若是使用则编译不会报错，但在运行时出错。`HashMap`只允许一个null的key，可以有多个null的value

```java
import java.util.HashTable;


public class Test {
    public static void main(String[] args) {
        HashTable<String, String> map = new HashTable<>();
        map.put("张三", "19");
        map.put("李四", "18");
        map.put("张三", "18");
        System.out.println(map);
        Set<Map.Entry<String, String>> entrySet = map.entrySet();
        for (Map.Entry<String, String> entry : entrySet) {
            System.out.println(entry.getKey() + "--->" + entry.getValue());
        }
    }
}
```

### TreeMap

`TreeMap`是`Map`接口的常用实现类，底层数据结构是红黑树，是有序的`Map`集合，`TreeMap`中的key要求具备比较规则。如果使用自定义的类作为key时，要求自定的类实现`Comparable`接口，如果自定义的类没有实现`Comparable`接口，可以编写一个类实现`Comparator`接口，调用`TreeMap`的带参构造方法创建`TreeMap`对象。

基础操作

```java
import java.util.Collection;
import java.util.TreeMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

public class Test {
    public static void main(String[] args) {
        // 创建TreeMap集合对象，key为String，value为Person
        TreeMap<String, Person> tm = new TreeMap<String, Person>();
        // 创建Person类型的对象,因为Person在这里做value，无需重写hashCode()和equals()方法
        // Person的name为key，String类实现了Comparable接口，具备比较大小的能力
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        tm.put(p1.getName(), p1);
        tm.put(p2.getName(), p2);
        tm.put(p3.getName(), p3); // p1被覆盖
        System.out.println(tm.size());
        System.out.println(tm);
        // judge
        System.out.println(tm.containsKey("lucy"));
        System.out.println(tm.containsValue(p1));
        // for
        // 获取所有key，然后根据每个key去获取相对应的value
        Set<String> setStr = tm.keySet(); // 获取所有key,有序排列
        for (String str : setStr) {
            System.out.println("key->" + str);
            System.out.println("value->"+ tm.get(str));
        }
        for (Iterator<String> ite = setStr.iterator(); ite.hasNext();) {
            // 获取key
            String key = ite.next();
            System.out.print("key->" + key);
            // 获取value
            Person p = tm.get(key);
            System.out.println("value->" + p.getName() + "\t" + p.getAge());
        }
        // 获取所有的value
        Collection<Person> colValues = tm.values();
        for (Person p : colValues) {
            System.out.println("value->" + p.getName() + "\t" + p.getAge());
        }
        // 获取所有key-value关系
        Set<Map.Entry<String, Person>> setMap = tm.entrySet();
        for (Iterator<Map.Entry<String, Person>> ite = setMap.iterator(); ite.hasNext();) {
            // 获取每一组的key-value
            Map.Entry<String, Person> pEntry = ite.next();
            // 从key-value关系中的到key,value
            String key = pEntry.getKey();
            Person p = pEntry.getValue();
            System.out.println("key->" + key + "\n" + "value->" + p.getName() + p.getAge());

        }
    }
}

// Person.java
public class Person {
    // 私有属性
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // 构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

}
```

自定义对象

```java
import java.util.TreeMap;

public class Test {
    public static void main(String[] args) {
        // 创建TreeMap集合对象，使用自定义的类为可以
        TreeMap<Person, String> tm = new TreeMap<Person, String>();
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        tm.put(p1, p1.getName());
        tm.put(p2, p2.getName());
        tm.put(p3, p3.getName()); // p1被覆盖
        System.out.println(tm.size());
        System.out.println(tm);
    }
}


public class Person {
    // 私有属性
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // 构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

}

/*方法一：Test类不变，Person中实现Comparable接口*/
public class Person implements Comparable<Person> {
    // 私有属性
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    // 构造方法
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }

    public Person() {
        super();
    }

    // 添加compareTo方法
    @Override
    public int compareTo(Person o) {
        if (this.getAge() < o.getAge()) {
            return -1; // 比较大小
        } else if (this.getAge() > o.getAge()) {
            return 1;
        } else {
            return this.getName().compareTo(o.getName());
        }
    }

}

/*方法二：Person类不变，Test类中变化*/
import java.util.Comparator;
import java.util.TreeMap;

public class Test {
    public static void main(String[] args) {
        // 创建TreeMap集合对象，使用自定义的类为可以
        TreeMap<Person, String> tm = new TreeMap<Person, String>(
            // 创建匿名内部类
            new Comparator<Person>(){
                @Override
                // 按照字母的长度进行排序
                public int compare(Person o1, Person o2){
                    return o1.getName().length() - o2.getName().length();
                }
            }
        );
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        tm.put(p1, p1.getName());
        tm.put(p2, p2.getName());
        tm.put(p3, p3.getName()); // p1被覆盖
        System.out.println(tm.size());
        System.out.println(tm);
    }
}

/*方法三：Person类不变，添加新的类LengthCom，Test类中变化*/
import java.util.Comparator;
import java.util.TreeMap;

public class Test {
    public static void main(String[] args) {
        Comparator<Person> com = new LengthCom();
        // 创建TreeMap集合对象，使用自定义的类为可以
        TreeMap<Person, String> tm = new TreeMap<Person, String>(com);
        Person p1 = new Person("jack", 12);
        Person p2 = new Person("lucy", 13);
        Person p3 = new Person("jack", 11);
        // add
        tm.put(p1, p1.getName());
        tm.put(p2, p2.getName());
        tm.put(p3, p3.getName()); // p1被覆盖
        System.out.println(tm.size());
        System.out.println(tm);
    }
}

import java.util.Comparator;

public class LengthCom implements Comparator<Person>{
    @Override
    // 按照字母的长度进行排序
    public int compare(Person o1, Person o2){
        return o1.getName().length() - o2.getName().length();
    }
    
}
```

## JDK9对集合添加优化

之前，需要手动add

```java
public class Demo01 {
	public static void main(String[] args) {
		List<String> list = new ArrayList<>(); list.add("abc");
		list.add("def");
		list.add("ghi"); System.out.println(list);
	} 
}
```

jdk9之后，添加了几种集合工厂方法,更方便创建少量元素的集合、map实例。新的List、Set、Map的静态工厂方法可 以更方便地创建集合的不可变实例。

```java
public class HelloJDK9 {
	public static void main(String[] args) {
		Set<String> str1=Set.of("a","b","c"); 
        //str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 
        System.out.println(str1);
		Map<String,Integer> str2=Map.of("a",1,"b",2);
		System.out.println(str2);
		List<String> str3=List.of("a","b");
		System.out.println(str3);
	}
}
```

注意

```
1. of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如 HashSet，ArrayList等待;
2. 返回的集合是不可变的，不能再使用add,put方法。
3. set和map接口在调用of方法时，不能有重复元素，否则异常
```

## Collections

`Collections`与`Collection`不同，`Collection`是集合框架体系顶层接口，而`Collections`是集合操作的一个工具类，里面有许多方法可供使用。

### 常用方法

```java
public static <T> boolean addAll(Collection<T> c, T... elements)
// 往集合中添加一些元素。 
    
public static void shuffle(List<?> list) 
// 打乱顺序 :打乱集合顺序。
    
public static <T> void sort(List<T> list) 
// 将集合中元素按照默认规则排序。
    
public static <T> void sort(List<T> list，Comparator<? super T> )
// 将集合中元素按照指定规则排序。
    
public static<T> void fill(List<?super T>list, T obj)
// 使用指定对象填充整个集合
    
public static<T> boolean repalceAll(List<T> list, T oldVal, T newVal)
// 使用新对象替换集合中的指定对象
```

实现

```java
import java.util.ArrayList;
import java.util.Collections;

public class Test {
    public static void main(String[] args) {
        ArrayList<String> coll = new ArrayList<String>();
        // add
        Collections.addAll(coll, "hello", "world", "java");
        System.out.println("coll的个数：" + coll.size());
        System.out.println("coll：" + coll);
        // sort
        Collections.sort(coll);
        System.out.println("coll排序后：" + coll);
        // search
        System.out.println("查找java位置:" + Collections.binarySearch(coll, "java"));
        System.out.println("查找html位置:" + Collections.binarySearch(coll, "html")); // 不存在，返回-(插入点+1)，插入点为：若是插入数据，则其应处于的位置
        // replace
        System.out.println("替换前：" + coll);
        Collections.replaceAll(coll, "java", "python");
        System.out.println("替换后：" + coll);
        // fill
        System.out.println("填充前：" + coll);
        Collections.fill(coll, "hi");
        System.out.println("填充后：" + coll); 
    }
}
```

### Comparator

排序就是两个对象之间比较大小，在JAVA中提供了两种比较实现的方式，方法一：采用`java.lang.Comparable`接口去实现，比较固定。方法二：做排序的时候在去选择的`java.util.Comparator `接口完成，比较灵活。

`Comparable`强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序，类的compareTo方法 被称为它的自然比较方法。只能在类中实现`compareTo()`一次，不能经常修改类的代码实现自己想要的排序。实现此接口的对象列表(和数组)可以通过Collections.sort(和Arrays.sort)进行自动排序，对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器。

`Comparator`强行对某个对象进行整体排序。可以将Comparator 传递给sort方法(如Collections.sort或 Arrays.sort)，从而允许在排序顺序上实现精确控制。还可以使用Comparator来控制某些数据结构(如有序set或 有序映射)的顺序，或者为那些没有自然顺序的对象collection提供排序。

- `Comparable`

`String`就是实现了`Comparable`接口，进行比较

```java
public final class String implements java.io.Serializable, Comparable<String>, CharSequence {
```

使用的是默认的规则完成字符串的排序。

```java
public class CollectionsDemo2 {
  	public static void main(String[] args) {
      	ArrayList<String>  list = new ArrayList<String>();
      	list.add("cba");
      	list.add("aba");
      	list.add("sba");
        list.add("nba"); 
        //排序方法 
        Collections.sort(list); 
        System.out.println(list);
} }
```

自定义对象排序

```java
// 自定义类
import java.util.Objects;

public class Student implements Comparable<Student> {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }


    public void setAge(int age) {
        this.age = age;
    }


    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }

    @Override
    public int compareTo(Student o) {
        return this.age - o.age; // 生序
    }
}

// 测试类
import java.util.ArrayList;
import java.util.Collections;

public class Test {
    public static void main(String[] args) {
        ArrayList<Student> list1 = new ArrayList<>();
        list1.add(new Student("abc", 10));
        list1.add(new Student("bca", 12));
        list1.add(new Student("cba", 5));
        Collections.sort(list1);  // 排序对象必须实现了Comparable接口中的compareTo方法
        System.out.println(list1);
    }
}
```

- `Comparator`

```java
public static <T> void sort(List<T> list，Comparator<? super T> )
```

使用

```java
import java.util.*;

public class HashSetDemo {
    public static void main(String[] args) {
        ArrayList<String> list1 = new ArrayList<>();
        list1.add("cba");
        list1.add("abc");
        list1.add("bac");
        Collections.sort(list1, new Comparator<String>() {
            @Override
            public int compare(String o1, String o2) {
                return o1.charAt(0) - o2.charAt(0);  // 升序
                // return o2.charAt(0) - o1.charAt(0);  // 降序
            }
        });
        System.out.println(list1);
    }
}
```

自定义对象排序

```java
// 自定义类
import java.util.Objects;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

// 测试类
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;

public class Test {
    public static void main(String[] args) {
        ArrayList<Student> list1 = new ArrayList<>();
        list1.add(new Student("abc", 10));
        list1.add(new Student("bca", 12));
        list1.add(new Student("cba", 5));
        Collections.sort(list1, new Comparator<Student>() {
            @Override
            public int compare(Student o1, Student o2) {
                return o1.getAge() - o2.getAge(); // 升序
            }
        });
        System.out.println(list1);
    }
}

```

## 数组与集合转换

数组与集合之间的转换是相互的。

数组转换成集合，因为数组的特点为有序、不唯一，所以只限于将数组转换为`List`集合。

集合转化成数组，可以将任意的集合转换成数组，所使用到的是`Collection`接口中的方法，而不是`Collections`类中的方法。

```java
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        // 数组转集合
        int[] arr = new int[] { 18, 20, 30 };
        List list = Arrays.asList(arr);
        System.out.println("集合中元素的个数：" + list.size());
        System.out.println("集合内容：" + list);
        Integer[] arrB = new Integer[] { 18, 20, 30 };
        List<Integer> list2 = Arrays.asList(arrB);
        System.out.println("集合中元素的个数：" + list2.size());
        System.out.println("集合内容：" + list2);
        // 集合转数组
        Collection<String> set = new HashSet<String>();
        Collections.addAll(set, "hello", "world", "java"); // add
        // 返回一个Object类型的数组
        // 数组长度等于集合中元素的个数
        Object[] objs = set.toArray();
        for (Object obj : objs) {
            System.out.println(obj);
        }
        // 返回指定类型的数组
        // 数组长度大于集合中元素的个数，将以null填充
        String[] str = new String[5];
        str = set.toArray(str);
        for (String s : str) {
            System.out.println(s + "\t");
        }
        // 数组长度小于集合中元素的个数，则以集合中的元素个数作为数组的长度
        String[] str2 = new String[2];
        str2 = set.toArray(str2);
        for (String s : str2) {
            System.out.println(s + "\t");
        } 
    }
}
```



